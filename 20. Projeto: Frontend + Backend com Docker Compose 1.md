
# Projeto: Frontend + Backend com Docker Compose (Parte 1)

Este projeto mostra **como rodar um frontend e um backend juntos** usando **Docker Compose**, de forma **simples e didática**.  
O backend será em **Python**, e o frontend será um **HTML/JS básico**, apenas para demonstrar a comunicação.

Esta é a **Parte 1**: foco em **estrutura, comunicação e Docker Compose** (sem banco ainda).

---

## 1) Objetivo do projeto

Ao final deste projeto, você vai:
- rodar dois serviços (frontend e backend)
- entender como frontend chama o backend
- usar Docker Compose para orquestrar tudo
- entender redes e portas na prática
- ter uma base para projetos full stack

---

## 2) Arquitetura do projeto

```

Navegador
│
▼
Frontend (HTML + JS) ───▶ Backend (Python API)

```

Importante:
- frontend roda no navegador
- backend roda em container
- comunicação ocorre via **porta exposta do backend**

---

## 3) Estrutura do projeto

Crie a seguinte estrutura:

```

frontend-backend-compose/
├── backend/
│   ├── app.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── index.html
│   └── Dockerfile
└── docker-compose.yml

````

---

## 4) Backend Python (API simples)

### `backend/app.py`

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.get("/api/hello")
def hello():
    return jsonify(message="Olá do backend Python")

@app.get("/health")
def health():
    return jsonify(status="ok")

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
````

Essa API tem:

* um endpoint público `/api/hello`
* um endpoint `/health` para testes

---

### `backend/requirements.txt`

```txt
flask==3.0.0
```

---

## 5) Dockerfile do backend

### `backend/Dockerfile`

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 5000

CMD ["python", "app.py"]
```

Esse Dockerfile:

* cria a imagem do backend
* expõe a porta 5000
* roda o Flask simples (modo didático)

---

## 6) Frontend simples (HTML + JS)

### `frontend/index.html`

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Frontend simples</title>
</head>
<body>
  <h1>Frontend + Backend com Docker Compose</h1>
  <button onclick="loadMessage()">Chamar backend</button>
  <p id="result"></p>

  <script>
    function loadMessage() {
      fetch("http://localhost:5000/api/hello")
        .then(response => response.json())
        .then(data => {
          document.getElementById("result").innerText = data.message;
        })
        .catch(err => {
          document.getElementById("result").innerText = "Erro ao chamar backend";
        });
    }
  </script>
</body>
</html>
```

Observação importante:

* o frontend chama o backend pela porta exposta no host
* isso é comum em projetos simples e em desenvolvimento

---

## 7) Dockerfile do frontend

Aqui vamos usar **Nginx** para servir o HTML.

### `frontend/Dockerfile`

```dockerfile
FROM nginx:alpine

COPY index.html /usr/share/nginx/html/index.html
```

Simples:

* Nginx serve o HTML estático
* nenhuma configuração extra

---

## 8) Docker Compose (docker-compose.yml)

Este arquivo conecta tudo.

```yaml
services:
  backend:
    build: ./backend
    ports:
      - "5000:5000"

  frontend:
    build: ./frontend
    ports:
      - "8080:80"
    depends_on:
      - backend
```

O que acontece:

* Compose cria uma rede interna
* backend é exposto na porta 5000
* frontend é exposto na porta 8080
* navegador acessa o frontend
* frontend chama o backend

---

## 9) Subindo o projeto

Na raiz do projeto:

```bash
docker compose up --build
```

Você verá:

* logs do backend
* logs do Nginx

---

## 10) Testando no navegador

1. Abra:

   ```
   http://localhost:8080
   ```
2. Clique em **"Chamar backend"**
3. Você deve ver:

   ```
   Olá do backend Python
   ```

Isso confirma:

* frontend está funcionando
* backend está rodando
* comunicação ocorreu com sucesso

---

## 11) Pontos importantes aprendidos

* Docker Compose gerencia múltiplos serviços
* Cada serviço tem seu Dockerfile
* Portas conectam host ↔ container
* Frontend pode chamar backend via porta exposta
* `depends_on` organiza a inicialização

---

## 12) Limitações deste exemplo (intencional)

Este projeto é **didático**.

Limitações:

* frontend chama backend via `localhost`
* não há variáveis de ambiente
* Flask roda em modo simples
* não há banco de dados

Tudo isso será melhorado na **Parte 2**.

---

## 13) Próxima evolução (Parte 2)

No próximo passo, podemos evoluir para:

* usar variáveis de ambiente
* configurar URLs por ambiente
* usar Gunicorn no backend
* frontend chamando backend pela rede interna
* Nginx como reverse proxy
* separar dev e prod

Esse projeto é a base para **full stack com Docker**.

