
# Variáveis de ambiente em containers Docker

Variáveis de ambiente são a **forma padrão e recomendada** de configurar aplicações em containers.  
Elas permitem separar **código** de **configuração**, o que é fundamental em ambientes profissionais.

---

## 1) O problema que variáveis de ambiente resolvem

Sem variáveis de ambiente, é comum ver:
- senhas hardcoded no código
- URLs fixas para banco de dados
- múltiplas versões do mesmo código para ambientes diferentes

Isso gera:
- risco de segurança
- dificuldade de deploy
- manutenção complicada

Variáveis de ambiente resolvem isso ao permitir que o **mesmo container** funcione em ambientes diferentes apenas mudando a configuração.

---

## 2) O que são variáveis de ambiente

Variáveis de ambiente são pares `CHAVE=VALOR` disponíveis para a aplicação em tempo de execução.

Exemplos:
```txt
DATABASE_URL=postgresql://user:pass@db:5432/app
SECRET_KEY=supersecreta
DEBUG=false
````

A aplicação lê essas variáveis do sistema operacional (ou container).

---

## 3) Definindo variáveis de ambiente com `docker run`

### 3.1 Usando a flag `-e`

```bash
docker run -e DEBUG=true -e PORT=5000 flask_app
```

Cada `-e` define uma variável.

---

### 3.2 Passando variáveis diretamente

```bash
docker run -e DATABASE_URL=postgres://user:pass@db:5432/app flask_app
```

Funciona bem para testes rápidos, mas não escala.

---

## 4) Usando arquivo `.env`

Para múltiplas variáveis, use um arquivo `.env`.

### Exemplo de `.env`

```env
DEBUG=true
PORT=5000
DATABASE_URL=postgres://user:pass@db:5432/app
SECRET_KEY=chave-super-secreta
```

### Rodando com `.env`

```bash
docker run --env-file .env flask_app
```

Vantagens:

- organização
- reutilização
- menos risco de erro

---

## 5) Variáveis de ambiente no Docker Compose

Docker Compose é o local mais comum para usar variáveis de ambiente.

---

### 5.1 Diretiva `environment`

```yaml
services:
  api:
    image: flask_app
    environment:
      DEBUG: "true"
      PORT: 5000
```

Observação:

- valores são strings
- use aspas quando necessário

---

### 5.2 Usando arquivo `.env` no Compose

Docker Compose carrega automaticamente um arquivo `.env` na raiz do projeto.

#### `.env`

```env
POSTGRES_DB=app
POSTGRES_USER=user
POSTGRES_PASSWORD=pass
```

#### `docker-compose.yml`

```yaml
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: ${POSTGRES_DB}
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
```

O Compose substitui automaticamente os valores.

---

### 5.3 Usando `env_file`

```yaml
services:
  api:
    image: flask_app
    env_file:
      - .env
```

Diferença:

- `env_file` injeta variáveis no container
- `.env` também pode ser usado para interpolação no Compose

---

## 6) Lendo variáveis de ambiente na aplicação

### Exemplo em Python (Flask)

```python
import os

DEBUG = os.getenv("DEBUG", "false") == "true"
DATABASE_URL = os.getenv("DATABASE_URL")
```

Nunca assuma que a variável existe sem fallback ou validação.

---

### Exemplo em Node.js

```js
const port = process.env.PORT || 3000;
const databaseUrl = process.env.DATABASE_URL;
```

---

## 7) Variáveis de ambiente no Dockerfile

Você pode definir variáveis default no Dockerfile com `ENV`.

```dockerfile
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
```

Importante:

- `ENV` define valores padrão
- pode ser sobrescrito em runtime (`docker run`, Compose)

---

## 8) O que NÃO fazer com variáveis de ambiente

### 8.1 Não colocar segredos no Dockerfile

Errado:

```dockerfile
ENV SECRET_KEY=supersecreta
```

Problemas:

- segredo fica na imagem
- imagem pode ser publicada em registry
- histórico do Dockerfile expõe o valor

---

### 8.2 Não commitar `.env` no repositório

Boas práticas:

- adicionar `.env` ao `.gitignore`
- criar `.env.example`

```txt
# .env.example
DATABASE_URL=
SECRET_KEY=
DEBUG=
```

---

## 9) Variáveis de ambiente vs arquivos de configuração

Em containers:

- variáveis de ambiente são o padrão
- arquivos de configuração são exceção

Motivos:

- mais fáceis de trocar por ambiente
- funcionam bem com CI/CD
- compatíveis com cloud e orquestradores

---

## 10) Variáveis de ambiente e segurança

Boas práticas:

- nunca logar segredos
- usar valores mínimos necessários
- separar credenciais por ambiente
- usar secrets managers em produção (quando disponível)

Exemplos:

- Docker Secrets
- Kubernetes Secrets
- Secrets da cloud (AWS, GCP, Azure)

---

## 11) Exemplo completo: Flask + PostgreSQL

### `.env`

```env
FLASK_ENV=production
DATABASE_URL=postgresql://user:pass@db:5432/app
SECRET_KEY=chave-secreta
```

---

### `docker-compose.yml`

```yaml
services:
  api:
    build: .
    env_file:
      - .env
    depends_on:
      - db

  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
```

---

### Código Flask

```python
import os

DATABASE_URL = os.getenv("DATABASE_URL")
SECRET_KEY = os.getenv("SECRET_KEY")
```

O mesmo código funciona em:

- desenvolvimento
- staging
- produção

---

## 12) Erros comuns

- Hardcode de senhas no código
- Esquecer de passar variáveis no container
- Assumir que `.env` sempre existe
- Usar `ENV` no Dockerfile para segredos
- Confundir `.env` do Compose com `env_file`

---

## 13) Checklist rápido

-  Código não contém segredos
-  `.env` está no `.gitignore`
-  `.env.example` documentado
-  Variáveis lidas via `os.getenv` / `process.env`
-  Defaults definidos quando possível
-  Segredos passados apenas em runtime

---

## 14) Conclusão

Variáveis de ambiente são a base da configuração em containers:

- desacoplam código de ambiente    
- aumentam segurança
- facilitam deploy e CI/CD
- permitem reutilizar imagens sem mudanças

Dominar esse conceito é essencial para trabalhar com Docker de forma profissional.

---

## 15) Próximos tópicos sugeridos

- Docker Secrets
- Healthchecks e readiness
- Configuração por ambiente (dev/staging/prod)
- Docker Compose avançado
- Orquestração e secrets em Kubernetes