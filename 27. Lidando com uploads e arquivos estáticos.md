
# Lidando com uploads e arquivos estáticos em aplicações com Docker

Este material explica **como lidar corretamente com uploads de arquivos e arquivos estáticos** em aplicações dockerizadas, de forma **didática**, **progressiva** e **próxima da realidade de produção**.

Aqui você vai aprender:
- diferença entre uploads e arquivos estáticos
- por que containers não devem armazenar arquivos localmente
- como usar volumes corretamente
- padrões comuns em Flask / backend web
- erros clássicos e boas práticas
- arquitetura correta para produção

---

## 1) O problema real

Em aplicações web, é comum lidar com:
- uploads de imagens
- PDFs
- arquivos gerados pela aplicação
- arquivos estáticos (CSS, JS, imagens públicas)

Erro comum de iniciantes:
> “Vou salvar os arquivos dentro do container”

Isso **funciona temporariamente**, mas **quebra em produção**.

---

## 2) Conceitos fundamentais

### 2.1 Arquivos estáticos

Arquivos que:
- não mudam com frequência
- fazem parte da aplicação
- são versionados junto com o código

Exemplos:
- CSS
- JavaScript
- imagens do frontend
- arquivos buildados (React, Vite)

---

### 2.2 Uploads (arquivos dinâmicos)

Arquivos que:
- são enviados por usuários
- mudam em runtime
- **não fazem parte da imagem**
- precisam persistir

Exemplos:
- fotos de perfil
- documentos
- anexos

---

## 3) Regra de ouro com Docker

> **Containers são descartáveis. Arquivos não.**

Consequências:
- arquivos dentro do container são perdidos ao recriar
- múltiplos containers não compartilham filesystem
- escalabilidade quebra se arquivos ficarem locais

Solução:
➡️ **Volumes**

---

## 4) O erro clássico (não faça isso)

```python
file.save("/app/uploads/foto.png")
````

Se `/app/uploads` estiver **dentro do container**:

* ao rebuild → arquivos somem
* ao escalar → inconsistência
* ao migrar → dados perdidos

---

## 5) A solução correta: volumes Docker

Volumes permitem:

* persistência
* compartilhamento
* separação entre código e dados

Exemplo básico:

```yaml
volumes:
  uploads:
```

---

## 6) Exemplo prático: Flask com uploads

### Estrutura do projeto

```
flask-uploads/
├── app.py
├── Dockerfile
├── docker-compose.yml
└── uploads/
```

---

### Código Flask (`app.py`)

```python
import os
from flask import Flask, request, jsonify
from werkzeug.utils import secure_filename

UPLOAD_FOLDER = "/data/uploads"

os.makedirs(UPLOAD_FOLDER, exist_ok=True)

app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

@app.post("/upload")
def upload():
    file = request.files["file"]
    filename = secure_filename(file.filename)
    file.save(os.path.join(app.config["UPLOAD_FOLDER"], filename))
    return jsonify(message="Upload realizado com sucesso")
```

Pontos importantes:

* caminho fora do código (`/data/uploads`)
* diretório criado em runtime
* nome do arquivo sanitizado

---

## 7) Dockerfile (simples)

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

CMD ["python", "app.py"]
```

Nenhuma lógica de volume aqui.
Volumes são responsabilidade do runtime (Compose).

---

## 8) Docker Compose com volume para uploads

```yaml
services:
  api:
    build: .
    ports:
      - "5000:5000"
    volumes:
      - uploads:/data/uploads

volumes:
  uploads:
```

Agora:

* arquivos persistem
* container pode ser recriado
* dados permanecem intactos

---

## 9) Testando persistência (passo essencial)

1. Faça upload de um arquivo
2. Pare os containers:

```bash
docker compose down
```

3. Suba novamente:

```bash
docker compose up
```

Resultado esperado:

* arquivos continuam existindo

Se não:

* o volume está errado

---

## 10) Bind mount vs volume nomeado

### Bind mount (mais comum em dev)

```yaml
volumes:
  - ./uploads:/data/uploads
```

Vantagens:

* arquivos visíveis no host
* fácil debug

Desvantagens:

* dependente do filesystem local
* não recomendado para produção

---

### Volume nomeado (recomendado)

```yaml
volumes:
  - uploads:/data/uploads
```

Vantagens:

* independente do host
* mais seguro
* padrão de produção

---

## 11) Arquivos estáticos (frontend / backend)

### Backend (Flask)

Arquivos estáticos geralmente:

* fazem parte do código
* vão dentro da imagem
* não precisam de volume

Exemplo:

```python
app = Flask(__name__, static_folder="static")
```

Dockerfile:

```dockerfile
COPY static/ /app/static/
```

---

### Frontend (React / HTML)

Arquivos estáticos:

* são gerados no build
* copiados para Nginx
* **não usam volume**

Exemplo:

```dockerfile
COPY --from=build /app/dist /usr/share/nginx/html
```

Isso é correto e esperado.

---

## 12) Uploads em frontend + backend

Fluxo comum:

```
Frontend → Backend → Volume
```

O frontend:

* nunca grava arquivos diretamente
* apenas envia via HTTP

O backend:

* valida
* salva no volume
* retorna referência

---

## 13) Servindo uploads (quando necessário)

Exemplo Flask:

```python
from flask import send_from_directory

@app.get("/uploads/<filename>")
def get_file(filename):
    return send_from_directory("/data/uploads", filename)
```

Cuidado:

* validação de acesso
* não expor tudo sem controle
* cuidado com path traversal

---

## 14) Produção: quando volumes não bastam

Em produção real, uploads geralmente vão para:

* S3
* GCS
* Azure Blob
* serviços externos

Volumes são bons para:

* pequenos projetos
* servidores únicos
* MVPs
* aprendizado

Arquitetura comum:

```
Backend → Object Storage
```

---

## 15) Erros comuns

* salvar arquivos dentro do container
* esquecer volume
* usar `localhost` para arquivos
* misturar código com dados
* não validar uploads
* não limitar tamanho de arquivo

---

## 16) Boas práticas

* separar código de dados
* usar volumes para uploads
* arquivos estáticos vão na imagem
* nunca confiar no nome do arquivo
* validar tipo e tamanho
* documentar caminhos de storage

---

## 17) Checklist rápido

* [ ] uploads fora do container
* [ ] volume configurado
* [ ] arquivos persistem após restart
* [ ] estáticos versionados com código
* [ ] backend controla uploads
* [ ] sem dados dentro da imagem

---

## 18) Conclusão

Lidar corretamente com uploads e arquivos estáticos:

* evita perda de dados
* permite escalar a aplicação
* mantém containers descartáveis
* aproxima o projeto de padrões profissionais

Esse é um ponto crítico que separa:

> “funciona localmente”
> de
> “funciona em produção”

---

## 19) Próximos tópicos sugeridos

* Uploads em cloud (S3)
* CDN para arquivos estáticos
* Nginx servindo uploads
* Segurança em uploads
* Cache de arquivos
* Migração de volumes

