
# Entendendo restart e dependências no Docker Compose

Quando trabalhamos com aplicações **multi-container**, dois problemas aparecem rápido:
1. O que acontece se um container cair?
2. Como garantir que um serviço dependa corretamente de outro?

Docker Compose resolve isso com:
- **políticas de restart**
- **dependências entre serviços**

Este guia explica esses conceitos de forma clara e prática.

---

## 1) O problema real

Imagine a arquitetura:

```

API (Flask) ───▶ Banco (PostgreSQL)

````

Situações comuns:
- o banco demora para subir
- a API tenta conectar cedo demais
- o container da API cai por erro temporário
- após reiniciar o host, serviços não voltam automaticamente

Sem configuração adequada:
- a aplicação falha
- você precisa intervir manualmente

---

## 2) Política de restart (restart policy)

A política de restart define **quando o Docker deve reiniciar um container automaticamente**.

Ela é definida com a chave `restart:` no Docker Compose.

---

## 3) Tipos de restart disponíveis

### 3.1 `no` (padrão)
```yaml
restart: "no"
````

- container **não** reinicia automaticamente
- padrão se nada for definido

---

### 3.2 `always`

```yaml
restart: always
```

- container reinicia sempre que parar
- reinicia após reboot do host
- não reinicia se você parar manualmente (`docker stop`)

Uso comum:

- serviços principais
- produção simples

---

### 3.3 `on-failure`

```yaml
restart: on-failure
```

- reinicia apenas se o container sair com erro (exit code ≠ 0)
- não reinicia se sair normalmente

Com limite:

```yaml
restart: on-failure:5
```

Uso comum:

- workers
- jobs
- tarefas assíncronas

---

### 3.4 `unless-stopped`

```yaml
restart: unless-stopped
```

- reinicia automaticamente
- inclusive após reboot
- exceto se você parar manualmente

Uso comum:

- produção
- servidores long-running

---

## 4) Exemplo simples de restart

```yaml
services:
  api:
    image: minha-api
    restart: unless-stopped
```

Resultado:

- se a API cair → Docker reinicia
- se o servidor reiniciar → API volta
- se você der `docker stop` → não volta sozinha

---

## 5) Dependências entre serviços (`depends_on`)

`depends_on` define **ordem de inicialização**, não disponibilidade real.

### Exemplo básico

```yaml
services:
  api:
    build: .
    depends_on:
      - db

  db:
    image: postgres:16
```

Resultado:

- `db` sobe antes de `api`
- **não garante** que o banco já esteja pronto para conexões

Esse ponto é crítico.

---

## 6) O erro mais comum com `depends_on`

Muita gente acha que:

> "`depends_on` garante que o banco esteja pronto"

Isso é falso.

O que ele garante:

- ordem de start

O que ele NÃO garante:

- banco pronto para aceitar conexões

---

## 7) Dependências com healthcheck (forma correta)

Para dependências reais, combine:

- `depends_on`
- `healthcheck`

### Exemplo com PostgreSQL

```yaml
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5

  api:
    build: .
    depends_on:
      db:
        condition: service_healthy
```

Agora:

- API só sobe quando o banco estiver saudável
- evita erros de conexão no startup

---

## 8) Restart + healthcheck juntos

Combinar restart e healthcheck cria serviços resilientes.

```yaml
services:
  api:
    image: minha-api
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3
```

Resultado:

- se a API travar → restart
- se ficar unhealthy → orquestradores podem agir
- logs ajudam no diagnóstico

---

## 9) Workers e jobs (caso especial)

Exemplo de worker:

```yaml
services:
  worker:
    image: minha-worker
    restart: on-failure:5
```

Uso ideal:

- jobs que podem falhar
- processamento assíncrono
- evitar loops infinitos

---

## 10) Restart não substitui código resiliente

Importante:

- restart ajuda
- mas não resolve tudo

Boas práticas no código:

- retry com backoff
- timeout de conexões
- validação de dependências
- tratamento de exceções

Docker não deve esconder bugs lógicos.

---

## 11) Ordem correta de pensamento

1. Código tolerante a falhas
2. Healthchecks claros
3. `depends_on` para ordem
4. Restart policy para resiliência

---

## 12) Erros comuns

- Achar que `depends_on` espera o serviço estar pronto
- Não usar healthcheck
- Usar `always` sem pensar
- Criar loops infinitos de restart
- Esconder falhas reais com restart agressivo

---

## 13) Exemplo completo (API + DB)

```yaml
services:
  api:
    build: .
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy

  db:
    image: postgres:16
    restart: unless-stopped
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user"]
      interval: 10s
      timeout: 5s
      retries: 5
```

---

## 14) Checklist rápido

-  Restart definido conscientemente
-  Healthcheck em serviços críticos
-  `depends_on` com `service_healthy`
-  Banco não exposto externamente
-  Código com retry e timeout

---

## 15) Conclusão

Restart e dependências:

- não são detalhes
- são essenciais para estabilidade
- evitam falhas intermitentes
- tornam o ambiente previsível

Entender bem esses dois pontos diferencia setups amadores de setups profissionais.

---

## 16) Próximos tópicos sugeridos

- Docker Compose profiles (dev/prod)
- Estratégias de retry no código
- Observabilidade com logs e métricas
- CI/CD com Docker Compose
- Migração para Kubernetes
