
# Testando variáveis de ambiente na prática (Docker)

Este guia é **100% prático**. O objetivo é **ver, testar e validar** variáveis de ambiente em containers Docker, para que você realmente entenda o que está acontecendo — e não apenas “configure e reze”.

---

## 1) Objetivo do teste

Ao final deste material, você será capaz de:
- definir variáveis de ambiente de diferentes formas
- verificar se elas chegaram ao container
- testar mudanças sem rebuild de imagem
- depurar problemas comuns com variáveis

---

## 2) Setup mínimo para os testes

Vamos usar um exemplo simples em **Python**, mas os conceitos valem para qualquer linguagem.

### Arquivo `app.py`
```python
import os

print("DEBUG =", os.getenv("DEBUG"))
print("PORT =", os.getenv("PORT"))
print("DATABASE_URL =", os.getenv("DATABASE_URL"))
````

Esse script apenas imprime as variáveis.

---

## 3) Teste 1 — Variáveis direto no `docker run`

### Rodando o container

```bash
docker run -e DEBUG=true -e PORT=5000 -e DATABASE_URL=db_url python:3.11 python -c "$(cat app.py)"
```

### O que verificar

- As variáveis aparecem no output
- Não foi necessário alterar código
- Não houve rebuild de imagem

Esse é o teste mais direto e útil para debug rápido.

---

## 4) Teste 2 — Usando arquivo `.env`

### Criar `.env`

```env
DEBUG=false
PORT=8000
DATABASE_URL=postgres://user:pass@db:5432/app
```

### Rodar com `--env-file`

```bash
docker run --env-file .env python:3.11 python -c "$(cat app.py)"
```

### O que verificar

- Todas as variáveis do arquivo aparecem
- Valores são lidos corretamente
- Nenhuma variável foi definida no código

---

## 5) Teste 3 — Conferindo variáveis dentro do container

Você pode entrar no container para verificar diretamente.

```bash
docker run -it --env-file .env python:3.11 bash
```

Dentro do container:

```bash
env | grep DEBUG
env | grep PORT
env | grep DATABASE_URL
```

Isso confirma:

- variáveis realmente existem no ambiente
- problema não está no Docker, mas no código (se algo falhar)

---

## 6) Teste 4 — Variáveis no Docker Compose

### `docker-compose.yml`

```yaml
services:
  app:
    image: python:3.11
    command: python -c "import os; print(os.getenv('DEBUG'))"
    environment:
      DEBUG: "true"
```

### Subir o serviço

```bash
docker compose up
```

### O que verificar

- variável aparece no log
- Compose injetou corretamente no container

---

## 7) Teste 5 — `.env` + Docker Compose

### `.env`

```env
DEBUG=true
```

### `docker-compose.yml`

```yaml
services:
  app:
    image: python:3.11
    command: python -c "import os; print(os.getenv('DEBUG'))"
    environment:
      DEBUG: ${DEBUG}
```

### Subir

```bash
docker compose up
```

Importante:

- Compose substitui `${DEBUG}` pelo valor do `.env`
- se a variável não existir, o valor será vazio

---

## 8) Teste 6 — Alterando variáveis sem rebuild

Isso é um ponto crítico.

### Passos

1. Suba o container com uma variável
2. Pare o container
3. Suba novamente com outro valor

```bash
docker run -e DEBUG=true python:3.11 python -c "import os; print(os.getenv('DEBUG'))"
docker run -e DEBUG=false python:3.11 python -c "import os; print(os.getenv('DEBUG'))"
```

Resultado:

- a imagem é a mesma
- apenas o ambiente muda

Isso prova que:

- variáveis são de runtime
- rebuild não é necessário

---

## 9) Teste 7 — Variáveis definidas no Dockerfile

### Dockerfile

```dockerfile
FROM python:3.11
ENV DEBUG=false
CMD ["python", "-c", "import os; print(os.getenv('DEBUG'))"]
```

### Build e run

```bash
docker build -t env-test .
docker run env-test
```

Output:

```txt
false
```

Agora sobrescrevendo:

```bash
docker run -e DEBUG=true env-test
```

Output:

```txt
true
```

Conclusão:

- `ENV` define valor padrão
- runtime sempre tem prioridade

---

## 10) Teste 8 — Variáveis ausentes (fallback)

Código seguro sempre usa fallback.

```python
import os

DEBUG = os.getenv("DEBUG", "false")
```

Teste:

```bash
docker run python:3.11 python -c "import os; print(os.getenv('DEBUG', 'false'))"
```

Resultado:

```txt
false
```

Nunca assuma que a variável existe.

---

## 11) Debugando problemas comuns

### Variável não aparece

Verifique:

```bash
env | grep NOME_DA_VARIAVEL
```

Se não aparecer:

- erro no `.env`
- erro no `env_file`
- erro de indentação no Compose

---

### Valor estranho (string vs boolean)

Lembre-se:

- variáveis são sempre strings

Exemplo em Python:

```python
DEBUG = os.getenv("DEBUG") == "true"
```

---

## 12) Boas práticas ao testar variáveis

- Teste com containers simples primeiro
- Verifique dentro do container (`env`)
- Use logs claros
- Separe config de código
- Documente variáveis esperadas

---

## 13) Checklist rápido

-  Variáveis chegam ao container
-  Código lê corretamente
-  Fallbacks existem
-  Nenhum segredo hardcoded
-  `.env` não commitado
-  Rebuild não é necessário para mudar config

---

## 14) Conclusão

Testar variáveis de ambiente na prática elimina:

- erros silenciosos
- configurações quebradas
- bugs difíceis de reproduzir

Esse domínio é essencial para:

- Docker
- Docker Compose
- CI/CD
- produção em cloud

---

## 15) Próximos tópicos sugeridos

- Docker Secrets
- Configuração por ambiente (dev/staging/prod)
- Healthchecks baseados em env
- CI/CD com variáveis
- Segurança em containers
