
# Continuação do projeto: Flask + Docker Compose (com banco, Gunicorn, env e healthcheck)

Vamos evoluir **o mesmo exemplo simples de Flask** para um cenário **mais próximo do mundo real**, adicionando:
- Docker Compose
- banco de dados (PostgreSQL)
- Gunicorn (servidor de produção)
- variáveis de ambiente com `.env`
- healthcheck
- logs básicos

Tudo **passo a passo**, sem pular conceitos.

---

## 1) Objetivo final

Ao final deste guia, você terá:
- uma API Flask rodando com Gunicorn
- PostgreSQL em container separado
- comunicação via Docker Compose
- configuração por variáveis de ambiente
- healthcheck funcionando
- logs visíveis via Docker

Arquitetura:

```

Flask (Gunicorn) ───▶ PostgreSQL

```

---

## 2) Estrutura do projeto

Vamos reorganizar levemente o projeto:

```

flask-docker-compose/  
├── app.py  
├── requirements.txt  
├── Dockerfile  
├── docker-compose.yml  
├── .env  
└── .dockerignore

````

---

## 3) Código Flask (app.py)

Vamos manter simples, mas já preparado para produção.

```python
import os
from flask import Flask, jsonify
import psycopg2

app = Flask(__name__)

DATABASE_URL = os.getenv("DATABASE_URL")

@app.get("/")
def home():
    return jsonify(message="Flask com Docker Compose e Gunicorn")

@app.get("/health")
def health():
    return jsonify(status="ok")

@app.get("/db-check")
def db_check():
    conn = psycopg2.connect(DATABASE_URL)
    cur = conn.cursor()
    cur.execute("SELECT 1;")
    cur.close()
    conn.close()
    return jsonify(database="connected")
````

Esse endpoint `/db-check` serve apenas para:

- validar conexão com o banco
- facilitar testes

---

## 4) Dependências (requirements.txt)

```txt
flask==3.0.0
gunicorn==21.2.0
psycopg2-binary==2.9.9
```

- `gunicorn`: servidor WSGI de produção
- `psycopg2-binary`: driver PostgreSQL

---

## 5) Variáveis de ambiente (.env)

Crie o arquivo `.env`:

```env
FLASK_ENV=production
DATABASE_URL=postgresql://postgres:postgres@db:5432/app
```

Importante:

- **não versionar** esse arquivo
- adicionar ao `.gitignore`

---

## 6) Dockerfile (usando Gunicorn)

Agora vamos ajustar o Dockerfile para produção.

```dockerfile
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 8000

CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

O que mudou em relação ao exemplo simples:

- Flask não usa mais servidor de desenvolvimento
- Gunicorn escuta em `0.0.0.0:8000`
- porta documentada com `EXPOSE`

---

## 7) Docker Compose (docker-compose.yml)

Aqui está o coração do projeto.

```yaml
services:
  api:
    build: .
    ports:
      - "8000:8000"
    env_file:
      - .env
    depends_on:
      - db
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3

  db:
    image: postgres:16
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
```

Pontos importantes:

- `api` acessa o banco pelo hostname `db`
- banco **não expõe portas**
- volume garante persistência
- healthcheck verifica `/health`

---

## 8) .dockerignore

Crie `.dockerignore`:

```txt
__pycache__
.env
.git
.gitignore
```

Isso:

- reduz tamanho da imagem
- evita vazamento de segredos

---

## 9) Subindo o projeto

Na raiz do projeto:

```bash
docker compose up --build
```

Você deve ver:

- logs do PostgreSQL
- logs do Gunicorn
- aplicação subindo corretamente

---

## 10) Testando a aplicação

### API

- [http://localhost:8000/](http://localhost:8000/)
- [http://localhost:8000/health](http://localhost:8000/health)
- [http://localhost:8000/db-check](http://localhost:8000/db-check)

Resposta esperada em `/db-check`:

```json
{"database":"connected"}
```

---

## 11) Healthcheck em ação

Veja o status do container:

```bash
docker ps
```

Você verá algo como:

```
healthy
```

Se o endpoint `/health` falhar:

- o container fica `unhealthy`
- orquestradores podem agir com base nisso

---

## 12) Logs da aplicação

### Ver logs da API

```bash
docker compose logs api
```

### Acompanhar em tempo real

```bash
docker compose logs -f api
```

Gunicorn envia logs para stdout:

- Docker captura
- Compose centraliza

Padrão moderno de logs.

---

## 13) O que você aprendeu nesse passo

- Docker Compose orquestra múltiplos serviços
- Flask em produção usa Gunicorn
- Variáveis de ambiente controlam configuração
- Banco de dados fica isolado
- Healthcheck monitora saúde da aplicação
- Logs fluem para o Docker

Esse é **um setup profissional mínimo**.

---

## 14) Diferença para desenvolvimento

Em desenvolvimento, normalmente você teria:

- bind mount de código    
- Flask com reload
- `.env.dev`

Em produção:

- imagem imutável
- Gunicorn
- volumes para dados
- envs injetadas pelo ambiente

---

## 15) Próximos passos naturais

A partir daqui, você pode evoluir para:

- migrations (Alembic)
- Flask Blueprint / arquitetura de pastas
- Nginx como reverse proxy
- CI/CD com Docker
- Deploy em cloud (Render, Fly.io, AWS)

