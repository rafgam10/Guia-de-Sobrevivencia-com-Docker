
# Otimizando builds para produção (Parte 1)

Este material é a **primeira parte** sobre otimização de builds Docker para **ambientes de produção**.  
O foco aqui é **entender o porquê das otimizações** e aplicar **melhorias simples e fundamentais**, antes de entrar em técnicas mais avançadas.

---

## 1) O problema de builds não otimizados

Um Dockerfile “ingênuo” funciona, mas em produção pode causar:

- imagens muito grandes
- builds lentos
- maior consumo de rede e disco
- deploy mais demorado
- maior superfície de ataque
- desperdício de recursos

Exemplo comum de problema:
```dockerfile
FROM python:latest
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
````

Funciona, mas é **ruim para produção**.

---

## 2) Objetivo da otimização (o que queremos alcançar)

Ao otimizar builds para produção, buscamos:

* imagens menores
* builds mais rápidos
* cache eficiente
* menos dependências desnecessárias
* maior segurança
* previsibilidade entre ambientes

O código da aplicação **não muda**.
O que muda é **como a imagem é construída**.

---

## 3) Escolhendo corretamente a imagem base

### 3.1 Evite `latest`

Problema:

```dockerfile
FROM python:latest
```

* muda sem aviso
* quebra builds antigos
* dificulta debug

Boa prática:

```dockerfile
FROM python:3.11-slim
```

Benefícios:

* versão previsível
* menor tamanho
* menos dependências

---

### 3.2 Prefira imagens menores (com critério)

Exemplos:

* `python:3.11-slim`
* `node:20-alpine`
* `nginx:alpine`

Cuidado:

* imagens `alpine` podem causar problemas com libs nativas
* não é regra absoluta, é decisão consciente

---

## 4) Aproveitando o cache de camadas do Docker

Docker usa cache baseado em **camadas**.

### Exemplo ruim

```dockerfile
COPY . .
RUN pip install -r requirements.txt
```

Resultado:

* qualquer mudança no código invalida o cache
* dependências reinstaladas sempre

---

### Exemplo otimizado

```dockerfile
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
```

Agora:

* dependências só reinstalam se `requirements.txt` mudar
* builds muito mais rápidos

---

## 5) Separando dependências do código

Esse é um dos **maiores ganhos de performance**.

### Python (exemplo recomendado)

```dockerfile
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
```

### Node.js

```dockerfile
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
```

Essa ordem **não é detalhe**, é essencial.

---

## 6) Removendo lixo do build com `.dockerignore`

Sem `.dockerignore`, você pode estar enviando para o build:

* `.git`
* `node_modules`
* arquivos temporários
* `.env`
* builds antigos

### Exemplo de `.dockerignore`

```txt
.git
.gitignore
.env
__pycache__
node_modules
dist
build
```

Benefícios:

* contexto de build menor
* builds mais rápidos
* imagens menores
* mais segurança

---

## 7) Limpando caches e arquivos temporários

### 7.1 APT (Debian/Ubuntu)

Exemplo ruim:

```dockerfile
RUN apt-get update && apt-get install -y curl
```

Exemplo otimizado:

```dockerfile
RUN apt-get update \
 && apt-get install -y --no-install-recommends curl \
 && rm -rf /var/lib/apt/lists/*
```

---

### 7.2 pip (Python)

```dockerfile
RUN pip install --no-cache-dir -r requirements.txt
```

Evita:

* cache desnecessário
* imagem maior

---

## 8) Reduzindo o número de camadas

Cada instrução cria uma camada.

Exemplo ruim:

```dockerfile
RUN apt-get update
RUN apt-get install -y curl
RUN rm -rf /var/lib/apt/lists/*
```

Exemplo melhor:

```dockerfile
RUN apt-get update \
 && apt-get install -y curl \
 && rm -rf /var/lib/apt/lists/*
```

Menos camadas:

* imagem menor
* build mais eficiente

---

## 9) Usando apenas o necessário em produção

Produção ≠ desenvolvimento.

Evite instalar:

* debuggers
* ferramentas de build
* utilitários que não são usados em runtime

Exemplo ruim:

```dockerfile
RUN apt-get install -y vim gcc make
```

Se não forem usados em runtime:

* não devem estar na imagem final

(Resolveremos isso melhor na Parte 2 com multi-stage build.)

---

## 10) Exemplo prático: Dockerfile Python otimizado (básico)

Antes:

```dockerfile
FROM python:latest
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "app.py"]
```

Depois (produção básica):

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

Ganho:

* imagem menor
* build mais rápido
* comportamento previsível

---

## 11) O que ainda NÃO fizemos (de propósito)

Nesta Parte 1, **ainda não usamos**:

* multi-stage build
* builds separados dev/prod
* stripping de binários
* distroless images

Esses tópicos vêm na **Parte 2**.

---

## 12) Erros comuns em otimização inicial

* otimizar sem medir
* usar `alpine` sem entender
* quebrar build por remover libs necessárias
* misturar dev e prod
* tentar otimizar tudo de uma vez

Otimização é **incremental**.

---

## 13) Checklist da Parte 1

* [ ] imagem base com versão fixa
* [ ] dependências copiadas antes do código
* [ ] `.dockerignore` configurado
* [ ] caches limpos
* [ ] menos camadas
* [ ] apenas dependências necessárias

---

## 14) Conclusão

Nesta Parte 1, você aprendeu a:

* evitar erros básicos
* ganhar performance facilmente
* reduzir tamanho da imagem
* preparar o terreno para produção

Essas otimizações já fazem **grande diferença**, mesmo sem técnicas avançadas.

---

## 15) Próximo passo (Parte 2)

Na Parte 2, vamos avançar para:

* multi-stage build
* separar build e runtime
* imagens ainda menores
* exemplos com Python e frontend
* padrão de produção real


