
# IntroduÃ§Ã£o ao Dockerfile

O **Dockerfile** Ã© o coraÃ§Ã£o do Docker.  
Ã‰ ele que define **como uma imagem Docker serÃ¡ criada**, passo a passo.

Se vocÃª entende Dockerfile, vocÃª entende Docker de verdade.

---

## O que Ã© um Dockerfile?

Um **Dockerfile** Ã© um arquivo de texto que contÃ©m **instruÃ§Ãµes** para o Docker criar uma **imagem**.

Essas instruÃ§Ãµes dizem:
- qual imagem base usar
- onde o cÃ³digo vai ficar
- quais dependÃªncias instalar
- qual comando executar

ğŸ“Œ Dockerfile **nÃ£o executa containers** â€” ele **cria imagens**.

---

## ğŸ“¦ Fluxo mental correto

```

Dockerfile â†’ Imagem â†’ Container

````

- Dockerfile â†’ receita
- Imagem â†’ bolo pronto
- Container â†’ bolo sendo comido ğŸ˜„

---

## ğŸ“„ Estrutura bÃ¡sica de um Dockerfile

Exemplo simples:

```dockerfile
FROM python:3.11
WORKDIR /app
COPY . .
RUN pip install flask
CMD ["python", "app.py"]
````

Cada linha Ã© uma **instruÃ§Ã£o**.

---

## ğŸ§± Principais instruÃ§Ãµes do Dockerfile

### ğŸ”¹ FROM

Define a **imagem base**.

```dockerfile
FROM python:3.11
```

ğŸ“Œ Todo Dockerfile (quase sempre) comeÃ§a com `FROM`.

---

### ğŸ”¹ WORKDIR

Define o diretÃ³rio de trabalho dentro do container.

```dockerfile
WORKDIR /app
```

- Evita usar caminhos absolutos repetidamente
- Cria o diretÃ³rio se nÃ£o existir

---

### ğŸ”¹ COPY

Copia arquivos do host para a imagem.

```dockerfile
COPY . .
```

Formato:

```dockerfile
COPY origem destino
```

---

### ğŸ”¹ RUN

Executa comandos **durante o build da imagem**.

```dockerfile
RUN pip install -r requirements.txt
```

ğŸ“Œ Tudo aqui acontece **antes** do container existir.

---

### ğŸ”¹ CMD

Define o comando **executado quando o container inicia**.

```dockerfile
CMD ["python", "app.py"]
```

ğŸ“Œ SÃ³ existe **um CMD ativo** por Dockerfile.

---

### ğŸ”¹ ENTRYPOINT (conceito bÃ¡sico)

Define o comando principal do container.

```dockerfile
ENTRYPOINT ["python", "app.py"]
```

Normalmente usado junto com `CMD`.

---

## ğŸ§  RUN vs CMD (diferenÃ§a importante)

|RUN|CMD|
|---|---|
|Executa no build|Executa no runtime|
|Cria camada na imagem|NÃ£o cria camada|
|Instala dependÃªncias|Inicia a aplicaÃ§Ã£o|

ğŸ“Œ **RUN constrÃ³i**, **CMD executa**.

---

## ğŸ—‚ï¸ Exemplo prÃ¡tico: Flask simples

### Estrutura do projeto

```
app/
 â”œâ”€â”€ app.py
 â”œâ”€â”€ requirements.txt
 â””â”€â”€ Dockerfile
```

---

### `requirements.txt`

```
flask
```

---

### `app.py`

```python
from flask import Flask

app = Flask(__name__)

@app.route("/")
def home():
    return "OlÃ¡, Docker!"

app.run(host="0.0.0.0", port=5000)
```

---

### Dockerfile

```dockerfile
FROM python:3.11
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
CMD ["python", "app.py"]
```

---

### Build da imagem

```bash
docker build -t flask-app .
```

---

### Rodar container

```bash
docker run -p 5000:5000 flask-app
```

---

## ğŸ§© Camadas (layers) do Dockerfile

Cada instruÃ§Ã£o cria uma **camada**:

```dockerfile
FROM python:3.11
COPY requirements.txt .
RUN pip install -r requirements.txt
```

ğŸ“Œ Docker reutiliza camadas iguais â†’ builds mais rÃ¡pidos.

ğŸ’¡ Por isso:

- copie `requirements.txt` antes do cÃ³digo
- evita reinstalar dependÃªncias sempre

---

## âš ï¸ Erros comuns com Dockerfile

- âŒ Copiar tudo antes de instalar dependÃªncias
- âŒ NÃ£o expor portas corretamente
- âŒ Usar `latest` sem necessidade
- âŒ Misturar responsabilidades no container
- âŒ Esquecer `.dockerignore`

---

## ğŸ“„ `.dockerignore` (muito importante)

Evita copiar arquivos desnecessÃ¡rios:

```txt
__pycache__/
.env
.git
node_modules
```

ğŸ“Œ Imagens menores = builds mais rÃ¡pidos.

---

## ğŸ“Œ Boas prÃ¡ticas iniciais

- Use imagens oficiais
- Evite imagens grandes
- Um serviÃ§o por container
- Versione imagens
- Use `.env` para configs


---

## ğŸ“Œ Resumo rÃ¡pido

- Dockerfile define como a imagem Ã© criada
- `FROM` escolhe a base
- `RUN` instala e prepara
- `CMD` inicia a aplicaÃ§Ã£o
- Dockerfile cria imagens, nÃ£o containers
