
# Otimizando builds para produção (Parte 2 – Final)

Nesta **Parte 2**, vamos finalizar o tema de otimização de builds Docker para **produção**, avançando para técnicas **mais profissionais e decisivas**.

Aqui você vai aprender:
- multi-stage build (conceito e prática)
- separar build e runtime
- reduzir drasticamente o tamanho da imagem
- evitar dependências de desenvolvimento em produção
- padrões reais usados em projetos profissionais

Esta parte fecha o ciclo iniciado na **Parte 1**.

---

## 1) Recapitulando a Parte 1 (contexto rápido)

Na Parte 1, você aprendeu a:
- escolher imagens base corretas
- aproveitar cache de camadas
- organizar o Dockerfile
- limpar caches
- reduzir camadas
- preparar o build para produção

Agora vamos **dar o salto de qualidade**.

---

## 2) O problema que ainda existe sem multi-stage build

Mesmo com boas práticas iniciais, ainda é comum ter imagens com:
- compiladores
- headers
- ferramentas de build
- dependências temporárias

Exemplo:
```dockerfile
RUN apt-get install -y gcc make
````

Essas ferramentas:

* são necessárias apenas no build
* **não devem ir para produção**

---

## 3) O que é multi-stage build

Multi-stage build permite:

* usar **múltiplas imagens base**
* separar **build** e **runtime**
* copiar apenas o que é necessário para a imagem final

Conceito:

```
Stage 1 (build) → compila/prepara
Stage 2 (runtime) → executa
```

Somente o Stage final vira a imagem.

---

## 4) Sintaxe básica do multi-stage build

```dockerfile
FROM imagem-base AS build
# comandos de build

FROM imagem-base-final
# copiar apenas o necessário do stage anterior
COPY --from=build /origem /destino
```

O Docker descarta tudo que não estiver no último stage.

---

## 5) Exemplo prático: Python com dependências nativas

### Sem multi-stage (ruim para produção)

```dockerfile
FROM python:3.11-slim

RUN apt-get update && apt-get install -y gcc

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY . .

CMD ["python", "app.py"]
```

Problema:

* `gcc` vai para produção
* imagem maior
* mais superfície de ataque

---

### Com multi-stage (correto)

```dockerfile
# Stage 1: build
FROM python:3.11-slim AS build

WORKDIR /build

RUN apt-get update \
 && apt-get install -y --no-install-recommends gcc \
 && rm -rf /var/lib/apt/lists/*

COPY requirements.txt .
RUN pip wheel --no-cache-dir --no-deps -r requirements.txt -w /wheels

# Stage 2: runtime
FROM python:3.11-slim

WORKDIR /app

COPY --from=build /wheels /wheels
COPY requirements.txt .

RUN pip install --no-cache-dir /wheels/*

COPY . .

CMD ["python", "app.py"]
```

Resultado:

* compiladores ficam apenas no stage de build
* imagem final muito menor
* runtime limpo

---

## 6) Exemplo prático: Frontend (build + runtime)

### Problema comum

Rodar frontend com Node em produção.

---

### Multi-stage correto

```dockerfile
# Stage 1: build
FROM node:20-alpine AS build

WORKDIR /app

COPY package.json package-lock.json ./
RUN npm ci

COPY . .
RUN npm run build

# Stage 2: runtime
FROM nginx:alpine

COPY --from=build /app/dist /usr/share/nginx/html

EXPOSE 80
```

Resultado:

* Node não vai para produção
* imagem final extremamente pequena
* apenas Nginx em runtime

---

## 7) Reduzindo ainda mais a imagem final

### 7.1 Usar imagens runtime mínimas

Exemplos:

* `python:3.11-slim`
* `nginx:alpine`
* `gcr.io/distroless/python3` (avançado)

Cuidado:

* imagens distroless são ótimas
* mas mais difíceis de debugar

---

### 7.2 Remover arquivos desnecessários

* testes
* documentação
* arquivos temporários
* exemplos

Use `.dockerignore` agressivo.

---

## 8) Separando Dockerfile de dev e prod

Padrões comuns:

### Opção 1: dois Dockerfiles

```
Dockerfile.dev
Dockerfile
```

### Opção 2: ARG para controle

```dockerfile
ARG ENV=production
```

Mas:

* multi-stage costuma ser mais limpo
* menos lógica condicional

---

## 9) Logs e processos corretos em produção

Produção exige:

* processo único
* logs em stdout/stderr
* sem daemons internos

Exemplo Python:

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Nunca:

* rodar múltiplos serviços no mesmo container
* usar `nohup`, `&`, `supervisord` sem motivo real

---

## 10) Comparativo final: antes vs depois

### Antes

* imagem grande
* build lento
* dependências extras
* insegurança

### Depois

* imagem pequena
* build rápido
* runtime limpo
* padrão profissional

---

## 11) Medindo resultados (recomendado)

Comandos úteis:

```bash
docker images
docker history nome-da-imagem
docker build --no-cache .
```

Compare:

* tamanho da imagem
* tempo de build
* número de camadas

---

## 12) Erros comuns em otimização avançada

* exagerar cedo demais
* usar distroless sem necessidade
* quebrar build por remover libs essenciais
* misturar dev e prod
* ignorar observabilidade

Otimização deve ser:

* consciente
* medida
* incremental

---

## 13) Checklist final de produção

* [ ] multi-stage build
* [ ] runtime sem ferramentas de build
* [ ] imagem base mínima
* [ ] cache eficiente
* [ ] `.dockerignore` agressivo
* [ ] processo único
* [ ] logs em stdout
* [ ] sem segredos na imagem

---

## 14) Conclusão final

Com as Partes 1 e 2, você agora entende:

* como otimizar builds Docker corretamente
* como separar build e runtime
* como reduzir tamanho e riscos
* como escrever Dockerfiles de nível profissional

Essas técnicas são usadas diariamente em:

* startups
* empresas grandes
* pipelines CI/CD
* produção em cloud

---

## 15) Próximos passos recomendados

* CI/CD com Docker
* Scan de vulnerabilidades
* Build cache remoto
* Kubernetes (conceitos)
* Observabilidade em produção
