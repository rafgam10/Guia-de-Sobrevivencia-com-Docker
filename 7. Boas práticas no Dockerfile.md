
# Boas práticas no Dockerfile

Este guia reúne boas práticas para escrever Dockerfiles mais rápidos, menores, mais seguros e fáceis de manter. As recomendações aqui valem para a maioria dos projetos (Python/Flask, Node/React, Java etc.) e ajudam tanto em desenvolvimento quanto em produção.

---

## 1) Escolha uma imagem base apropriada

### Prefira imagens oficiais e específicas
- Use imagens oficiais (por exemplo, `python`, `node`, `nginx`) e evite imagens desconhecidas.
- Prefira tags específicas em vez de `latest` para garantir reprodutibilidade.

Exemplos:
```dockerfile
FROM python:3.11-slim
# Em vez de: FROM python:latest
````

```dockerfile
FROM node:20-alpine
# Em vez de: FROM node:latest
```

### Entenda os trade-offs: slim vs alpine

- `slim`: geralmente mais compatível (glibc), menos dores com dependências nativas.
- `alpine`: muito pequena, porém pode gerar problemas com pacotes que exigem compilação e bibliotecas específicas (musl).

Regra prática:

- Em Python, muitas vezes `slim` reduz fricções.
- Em Node, `alpine` costuma funcionar bem para muitos casos, mas avalie dependências nativas.

---

## 2) Fixe versões para builds reproduzíveis

Reprodutibilidade significa: reconstruir amanhã e obter o mesmo resultado.

Boas práticas:

- Fixar versão da imagem base.
- Fixar dependências no gerenciador (pip, npm, etc.).

Python:

- Use `requirements.txt` com versões fixas (quando possível).
- Considere `pip-tools` (`requirements.in` → `requirements.txt`) para travar versões.

Node:

- Use `package-lock.json` ou `pnpm-lock.yaml` e instale com `npm ci`/`pnpm install --frozen-lockfile`.

---

## 3) Use o cache de camadas do Docker a seu favor

O Docker constrói imagens em camadas. Se uma camada não mudou, ela pode ser reutilizada e o build fica mais rápido.

### Padrão recomendado: copiar arquivos de dependências antes do código

Python:

```dockerfile
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
```

Node:

```dockerfile
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
```

Isso evita reinstalar dependências sempre que você muda o código-fonte.

---

## 4) Reduza o tamanho da imagem

Imagens menores:

- sobem mais rápido em deploy
- consomem menos disco
- reduzem superfície de ataque

Boas práticas:

- Use imagens base menores quando possível (`slim`, `alpine`).
- Limpe caches e arquivos temporários.
- Instale apenas o necessário.

Exemplo (Debian/Ubuntu):

```dockerfile
RUN apt-get update \
 && apt-get install -y --no-install-recommends curl \
 && rm -rf /var/lib/apt/lists/*
```

Python (pip):

```dockerfile
RUN pip install --no-cache-dir -r requirements.txt
```

---

## 5) Use `.dockerignore` para não copiar lixo para a imagem

Sem `.dockerignore`, você pode enviar para o build:

- `.git/`
- `node_modules/`
- arquivos temporários
- artefatos de build
- `.env`

Exemplo de `.dockerignore`:

```txt
.git
__pycache__
*.pyc
.env
node_modules
dist
build
.vscode
.DS_Store
```

Isso acelera o build e diminui a imagem.

---

## 6) Não rode como root (quando possível)

Rodar como root aumenta o impacto de um ataque ou falha de segurança.

Exemplo:

```dockerfile
RUN useradd -m appuser
USER appuser
```

Em imagens Alpine:

```dockerfile
RUN addgroup -S app && adduser -S app -G app
USER app
```

Observação:

- Algumas imagens oficiais já trazem usuários não-root (por exemplo, `nginx` em alguns cenários).
- Se sua aplicação precisa escrever em diretórios, garanta permissões adequadas (ex.: `chown`).

---

## 7) Use `WORKDIR` e caminhos consistentes

Evita comandos longos e reduz erros.

```dockerfile
WORKDIR /app
```

Depois disso, você pode usar caminhos relativos:

```dockerfile
COPY . .
```

---

## 8) Use `CMD` e `ENTRYPOINT` corretamente

### `CMD`

Define o comando padrão que roda quando o container inicia. Pode ser sobrescrito ao rodar `docker run`.

Exemplo:

```dockerfile
CMD ["python", "app.py"]
```

### `ENTRYPOINT`

Define o executável principal do container. Normalmente usado quando você quer que o container sempre execute algo específico.

Exemplo:

```dockerfile
ENTRYPOINT ["python", "app.py"]
```

### Recomendação prática

- Em aplicações, `CMD` costuma ser suficiente.
- Se precisar de argumentos flexíveis, combine `ENTRYPOINT` com `CMD`.

Exemplo:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--help"]
```

---

## 9) Use exec form (JSON array) em vez de shell form

Exec form evita problemas com sinais (SIGTERM) e parsing do shell.

Recomendado:

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Evite:

```dockerfile
CMD gunicorn -b 0.0.0.0:8000 app:app
```

---

## 10) Configure variáveis de ambiente com cuidado

Use `ENV` para defaults, mas evite colocar segredos (tokens, senhas) no Dockerfile.

```dockerfile
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1
```

Segredos devem ser passados em runtime:

- `docker run -e KEY=value ...`
- arquivos `.env` no Compose
- secrets no Kubernetes/Swarm/Cloud

---

## 11) Exponha portas de forma informativa (EXPOSE)

`EXPOSE` não publica portas, apenas documenta.

```dockerfile
EXPOSE 5000
```

Publicar portas é no runtime:

```bash
docker run -p 5000:5000 imagem
```

---

## 12) Healthcheck para melhorar observabilidade

`HEALTHCHECK` permite que Docker/Orquestrador saiba se o container está saudável.

Exemplo:

```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
  CMD curl -f http://localhost:5000/health || exit 1
```

Recomendação:

- Crie um endpoint `/health` simples no backend.
- Ajuste intervalos para o seu cenário.

---

## 13) Não use um container para múltiplos serviços (na maioria dos casos)

Um container deve ter um processo principal.

Evite:

- rodar API + banco + worker no mesmo container

Prefira:

- um container para API
- um para banco
- um para worker
- orquestrados com Docker Compose / Kubernetes

Isso simplifica scaling, logs e manutenção.

---

## 14) Multi-stage build (recomendação para produção)

Multi-stage reduz imagem final, separando build e runtime.

### Exemplo Node (build do front e servir com Nginx)

```dockerfile
# stage 1: build
FROM node:20-alpine AS build
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
RUN npm run build

# stage 2: runtime
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
```

### Exemplo Python (dependências e runtime limpo)

Em projetos com dependências nativas, você pode compilar em um stage e copiar apenas o necessário para o stage final. Nem sempre é obrigatório, mas pode ser útil.

---

## 15) Use um servidor de produção (não o dev server)

### Flask

Evite rodar o servidor de desenvolvimento em produção:

- `flask run` não é apropriado para produção

Prefira:

- `gunicorn`
- `uwsgi` (dependendo do caso)

Exemplo:

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

---

## 16) Defina um `.dockerignore` e mantenha o build context pequeno

Além de `.dockerignore`, considere o contexto:

- Evite rodar `docker build` apontando para diretórios enormes.
- Tenha uma estrutura de projeto organizada.

---

## 17) Ordene instruções do Dockerfile de forma intencional

Ordem recomendada (regra geral):

1. `FROM`
2. `WORKDIR`
3. Copiar arquivos de dependências
4. Instalar dependências (`RUN`)
5. Copiar o restante do código
6. `EXPOSE` (se aplicável)
7. `USER` (se aplicável)
8. `CMD`/`ENTRYPOINT`

Isso maximiza cache e clareza.

---

## 18) Exemplo completo: Dockerfile bem escrito para Flask

```dockerfile
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Pontos atendidos:

- imagem base menor (`slim`)
- variáveis de ambiente úteis
- dependências em camada separada para cache
- `--no-cache-dir`
- usuário não-root
- porta documentada com `EXPOSE`
- servidor de produção (`gunicorn`)
- exec form no `CMD`

---

## 19) Checklist rápido

-  Imagem base específica (evitar `latest`)
-  Dependências copiadas e instaladas antes do código
-  `.dockerignore` configurado
-  `pip --no-cache-dir` / `npm ci`
-  Limpeza de caches do sistema (`apt` etc.)
-  Exec form em `CMD`/`ENTRYPOINT`
-  Usuário não-root (quando possível)
-  Multi-stage build (quando faz sentido)
-  Healthcheck (quando aplicável)
-  Um serviço por container

---

## 20) Próximos tópicos recomendados

- Docker Compose com banco (PostgreSQL/MySQL) e Redis    
- Volumes (persistência e desenvolvimento)
- Redes Docker (services se enxergando por nome)
- Multi-stage build avançado
- Deploy com Docker (cloud, CI/CD, containers registry)
