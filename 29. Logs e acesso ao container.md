
# Logs e acesso ao container (guia completo e prático)

Este material explica **como lidar corretamente com logs e acesso a containers Docker**, de forma **didática**, **realista** e alinhada com **boas práticas de produção**.

Aqui você vai aprender:
- como funcionam logs em containers
- como acessar logs com Docker
- como entrar em containers para debug
- o que fazer e o que evitar em produção
- padrões profissionais de observabilidade

---

## 1) O problema comum

Iniciantes costumam:
- dar `ssh` no container
- salvar logs em arquivos internos
- perder logs ao recriar containers
- depender de debug manual

Em produção, isso **não escala**.

---

## 2) Regra de ouro dos logs em containers

> **Containers não guardam logs. Containers escrevem logs.**

Quem guarda logs é:
- Docker
- orquestrador
- sistema de logs centralizado

---

## 3) Logs em containers (stdout e stderr)

O padrão correto é:
- logs vão para **stdout** (`print`, `console.log`)
- erros vão para **stderr**

Exemplo Python:
```python
print("Aplicação iniciada")
````

Exemplo Node.js:

```js
console.log("Servidor iniciado");
console.error("Erro ao conectar");
```

Docker captura tudo automaticamente.

---

## 4) Acessando logs com Docker

### 4.1 Logs de um container

```bash
docker logs <container_id>
```

---

### 4.2 Logs em tempo real

```bash
docker logs -f <container_id>
```

---

### 4.3 Logs com Docker Compose

```bash
docker compose logs
docker compose logs -f
docker compose logs api
```

Muito mais prático em projetos multi-container.

---

## 5) Por que não salvar logs em arquivos internos

Exemplo ruim:

```python
logging.basicConfig(filename="app.log")
```

Problemas:

* logs ficam dentro do container
* são perdidos ao recriar
* difíceis de coletar
* não escalam

Correto:

```python
logging.basicConfig(level=logging.INFO)
```

---

## 6) Logs em produção (padrão real)

Fluxo real:

```
Aplicação → stdout/stderr → Docker → Logs centralizados
```

Ferramentas comuns:

* ELK Stack
* Loki + Grafana
* Datadog
* CloudWatch
* Stackdriver

---

## 7) Ajustando logs por ambiente

Exemplo com variável de ambiente:

```python
import os
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
```

No Compose:

```yaml
environment:
  LOG_LEVEL: DEBUG
```

Produção:

```yaml
LOG_LEVEL: INFO
```

---

## 8) Acessando o container (quando realmente necessário)

### 8.1 Entrar no container com shell

```bash
docker exec -it <container_id> bash
```

Ou:

```bash
docker exec -it <container_id> sh
```

Uso típico:

* debug emergencial
* inspeção de arquivos
* validação rápida

---

## 9) Acessando containers com Docker Compose

```bash
docker compose exec api bash
```

Muito mais simples:

* não precisa do ID
* usa nome do serviço

---

## 10) O que NÃO fazer ao acessar containers

* não editar código manualmente
* não corrigir bugs “na mão”
* não instalar pacotes em runtime
* não depender de acesso manual

Containers são descartáveis.

---

## 11) Debug correto vs incorreto

### Incorreto

* entrar no container
* editar arquivos
* resolver “na hora”

Ao recriar:

* tudo se perde

---

### Correto

* identificar problema via logs
* corrigir código
* rebuild da imagem
* redeploy

---

## 12) Comandos úteis de inspeção

```bash
docker ps
docker inspect <container_id>
docker stats
```

### `docker stats`

* CPU
* memória
* I/O
* ajuda a detectar gargalos

---

## 13) Logs de múltiplos serviços

Com Compose:

```bash
docker compose logs -f
```

Você vê:

* backend
* frontend
* banco
* tudo em um lugar

Ideal para debug integrado.

---

## 14) Logs e healthcheck

Healthchecks também aparecem nos logs.

Exemplo:

```yaml
healthcheck:
  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
```

Se falhar:

* container fica unhealthy
* logs ajudam a entender o motivo

---

## 15) Produção: acesso controlado

Em produção:

* acesso ao container deve ser raro
* feito apenas por pessoas autorizadas
* preferencialmente bloqueado

Boa prática:

* logs suficientes
* métricas
* alertas

Assim você **não precisa entrar no container**.

---

## 16) Erros comuns

* salvar logs em arquivos
* não usar logs
* depender de `exec` sempre
* debug manual constante
* misturar logs de dev e prod

---

## 17) Boas práticas resumidas

* logs sempre em stdout/stderr
* use níveis de log
* use Docker Compose para logs
* evite acesso manual
* trate containers como descartáveis
* centralize logs em produção

---

## 18) Checklist rápido

* [ ] logs em stdout/stderr
* [ ] logs acessíveis via `docker logs`
* [ ] `docker compose logs` funcionando
* [ ] acesso manual apenas para debug
* [ ] nenhuma correção manual em runtime

---

## 19) Conclusão

Logs e acesso a containers:

* são ferramentas de diagnóstico
* não são solução permanente
* devem ser usados com disciplina

Quando bem usados:

* problemas são resolvidos mais rápido
* produção fica estável
* deploys são previsíveis

---

## 20) Próximos tópicos sugeridos

* Observabilidade (métricas e traces)
* Debug sem acesso ao container
* Logs estruturados (JSON)
* Alertas e monitoramento
* Segurança em produção


