
# Trabalhando com volumes no Docker (Parte 2)

Este material continua o estudo de volumes, agora focando em **uso profissional**:
- volumes no Docker Compose
- compartilhamento entre serviços
- permissões
- backup e restore
- padrões comuns em projetos reais

---

## 1) Volumes no Docker Compose

No Docker Compose, volumes são definidos de forma declarativa no arquivo `docker-compose.yml`.

### Exemplo básico
```yaml
services:
  db:
    image: postgres:16
    volumes:
      - pgdata:/var/lib/postgresql/data

volumes:
  pgdata:
````

O que acontece:

- o volume `pgdata` é criado automaticamente
- os dados do banco persistem
- o container pode ser recriado sem perda de dados

---

## 2) Volume nomeado vs volume externo

### Volume gerenciado pelo Compose

```yaml
volumes:
  pgdata:
```

- criado e gerenciado pelo projeto
- removido com `docker compose down -v`

---

### Volume externo (já existente)

```yaml
volumes:
  pgdata:
    external: true
```

- o Compose não cria nem remove
- útil para dados compartilhados entre projetos
- comum em produção

---

## 3) Compartilhando volumes entre serviços

Um volume pode ser montado em mais de um container.

### Exemplo: backend + worker

```yaml
services:
  api:
    image: minha_api
    volumes:
      - uploads:/app/uploads

  worker:
    image: meu_worker
    volumes:
      - uploads:/app/uploads

volumes:
  uploads:
```

Uso comum:

- uploads de arquivos
- processamento assíncrono
- leitura/escrita compartilhada

Observação:

- cuidado com concorrência de escrita

---

## 4) Bind mounts no Docker Compose

Muito usado em desenvolvimento.

### Exemplo com Flask

```yaml
services:
  api:
    image: flask_app
    volumes:
      - .:/app
```

- código local espelhado no container
- ideal para hot reload
- não recomendado para produção

---

## 5) Permissões e ownership

Problema comum:

- container roda como usuário não-root
- volume montado pertence a outro usuário
- aplicação não consegue escrever

### Estratégias comuns

#### 1. Ajustar permissões no Dockerfile

```dockerfile
RUN chown -R appuser:appuser /app
```

#### 2. Ajustar permissões no runtime

```yaml
services:
  api:
    user: "1000:1000"
```

#### 3. Usar entrypoint para corrigir permissões

```bash
chown -R appuser:appuser /data
exec "$@"
```

A escolha depende do projeto e do ambiente.

---

## 6) Volumes e bancos de dados

### Padrões de caminhos comuns

- PostgreSQL: `/var/lib/postgresql/data`
- MySQL: `/var/lib/mysql`
- Redis: `/data`

Exemplo PostgreSQL:

```yaml
services:
  db:
    image: postgres:16
    volumes:
      - pgdata:/var/lib/postgresql/data
```

Nunca altere esses caminhos sem entender a imagem usada.

---

## 7) Backup de volumes

Volumes não fazem backup automaticamente.

### Backup simples com container temporário

```bash
docker run --rm \
  -v pgdata:/data \
  -v $(pwd):/backup \
  ubuntu \
  tar czf /backup/pgdata.tar.gz /data
```

Resultado:

- arquivo `pgdata.tar.gz` no host

---

### Restore de volume

```bash
docker run --rm \
  -v pgdata:/data \
  -v $(pwd):/backup \
  ubuntu \
  tar xzf /backup/pgdata.tar.gz -C /
```

---

## 8) Inspecionando volumes em produção

```bash
docker volume inspect pgdata
```

Mostra:

- driver
- ponto de montagem
- containers usando o volume

Útil para debug e auditoria.

---

## 9) Remoção segura de volumes

### Remover apenas containers

```bash
docker compose down
```

Volumes permanecem.

---

### Remover containers e volumes

```bash
docker compose down -v
```

Cuidado:

- dados são apagados permanentemente

---

## 10) Estratégias comuns em projetos reais

### Desenvolvimento

- bind mount para código
- volume nomeado para banco

### Produção

- volumes nomeados ou externos
- nunca bind mount de código
- backup automatizado

---

## 11) Anti-padrões comuns

- Usar bind mount em produção
- Compartilhar volume entre muitos serviços sem controle
- Depender de permissões implícitas
- Não documentar volumes
- Não fazer backup

---

## 12) Exemplo completo: Flask + PostgreSQL

```yaml
services:
  api:
    build: .
    volumes:
      - .:/app
    depends_on:
      - db

  db:
    image: postgres:16
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass

volumes:
  pgdata:
```

Separação clara:

- código: bind mount
- dados: volume

---

## 13) Checklist rápido

-  Volume nomeado para dados
-  Bind mount apenas em desenvolvimento
-  Caminhos corretos da imagem
-  Permissões verificadas
-  Backup documentado
-  Uso claro no Compose

---

## 14) Conclusão

Volumes são essenciais para:

- persistência
- confiabilidade
- segurança de dados

Entender volumes bem separa projetos amadores de projetos profissionais.

---

## 15) Próximos tópicos sugeridos

- Redes no Docker
- Docker Compose avançado
- Multi-container apps
- Deploy com volumes em cloud
- Migração e backup automatizado