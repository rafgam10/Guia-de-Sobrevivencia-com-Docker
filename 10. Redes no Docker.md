
# Redes no Docker

Redes no Docker permitem que **containers se comuniquem entre si** de forma isolada, previsível e segura.  
Entender redes é essencial para trabalhar com **Docker Compose**, **aplicações multi-container** e **produção**.

---

## 1) O problema que as redes resolvem

Sem redes bem definidas:
- containers não se enxergam facilmente
- é necessário usar IPs (frágil)
- comunicação fica difícil de manter

Docker resolve isso com **redes virtuais**, onde containers se comunicam **por nome**.

---

## 2) Conceito fundamental

Em uma rede Docker:
- cada container recebe um IP interno
- containers se comunicam usando o **nome do serviço/container**
- Docker faz o DNS interno automaticamente

Exemplo:
- backend → `db:5432`
- frontend → `api:8000`

Sem IP fixo, sem gambiarra.

---

## 3) Tipos de redes no Docker

### 3.1 Bridge (padrão)

- Rede padrão do Docker
- Usada quando você não especifica rede
- Containers se comunicam entre si na mesma bridge

```bash
docker network ls
````

Rede padrão:

```
bridge
```

Limitação:

- comunicação por IP ou nome do container (menos previsível)
- não ideal para produção

---

### 3.2 User-defined bridge (recomendada)

- Criada pelo usuário
- DNS automático por nome
- Isolamento melhor
- Padrão em projetos reais

```bash
docker network create minha_rede
```

Uso:

```bash
docker run --network minha_rede nginx
```

---

### 3.3 Host

- Container usa a rede do host diretamente
- Sem isolamento de portas

```bash
docker run --network host nginx
```

Uso comum:

- debugging
- casos muito específicos

Não recomendado para produção na maioria dos casos.

---

### 3.4 None

- Container sem rede

```bash
docker run --network none ubuntu
```

Uso:

- jobs isolados
- tarefas offline

---

## 4) Redes no Docker Compose

Docker Compose cria automaticamente uma rede bridge para o projeto.

### Exemplo simples

```yaml
services:
  api:
    image: minha_api

  db:
    image: postgres:16
```

Resultado:

- rede criada automaticamente
- `api` acessa `db` via hostname `db`

---

## 5) Comunicação entre serviços

### Exemplo: Flask + PostgreSQL

```yaml
services:
  api:
    build: .
    environment:
      DATABASE_URL: postgresql://user:pass@db:5432/app
    depends_on:
      - db

  db:
    image: postgres:16
```

Ponto-chave:

- `db` é o hostname
- nunca use `localhost` entre containers

---

## 6) Expondo serviços para fora

Comunicação externa usa **port mapping**, não redes internas.

```yaml
services:
  api:
    ports:
      - "8000:8000"
```

- interno: containers usam `api:8000`
- externo: host acessa `localhost:8000`

---

## 7) Múltiplas redes no Docker Compose

Um container pode participar de mais de uma rede.

### Exemplo comum: frontend + backend + banco

```yaml
services:
  frontend:
    image: react_app
    networks:
      - frontend_net

  api:
    image: flask_api
    networks:
      - frontend_net
      - backend_net

  db:
    image: postgres:16
    networks:
      - backend_net

networks:
  frontend_net:
  backend_net:
```

Resultado:

- frontend não acessa o banco diretamente
- api faz a ponte
- isolamento lógico claro

---

## 8) Isolamento e segurança

Redes ajudam a:

- limitar quem fala com quem
- reduzir superfície de ataque
- organizar arquitetura

Boas práticas:

- separar frontend, backend e banco
- não expor banco de dados com `ports`
- usar redes distintas para domínios diferentes

---

## 9) Inspecionando redes

```bash
docker network inspect minha_rede
```

Mostra:

- containers conectados
- IPs internos
- configurações

Útil para debug.

---

## 10) Removendo redes

### Remover rede específica

```bash
docker network rm minha_rede
```

### Remover redes não usadas

```bash
docker network prune
```

Cuidado:

- containers conectados impedem remoção

---

## 11) Erros comuns

- Usar `localhost` entre containers
- Expor banco de dados desnecessariamente    
- Usar IP fixo manualmente
- Misturar redes sem planejamento
- Confiar na bridge padrão para produção

---

## 12) Padrões comuns em projetos reais

### Desenvolvimento

- uma rede automática do Compose
- bind mounts para código
- volumes para banco

### Produção

- redes separadas por domínio
- banco sem `ports`
- apenas serviços públicos expostos

---

## 13) Exemplo completo: arquitetura típica

```yaml
services:
  frontend:
    image: react_app
    ports:
      - "3000:80"
    networks:
      - frontend

  api:
    image: flask_api
    networks:
      - frontend
      - backend

  db:
    image: postgres:16
    volumes:
      - pgdata:/var/lib/postgresql/data
    networks:
      - backend

volumes:
  pgdata:

networks:
  frontend:
  backend:
```

Arquitetura clara:

- frontend ↔ api
- api ↔ db
- frontend não vê o banco

---

## 14) Checklist rápido

-  Serviços se comunicam por nome
-  Nunca usar `localhost` entre containers
-  Bancos não expostos externamente
-  Redes separadas quando necessário
-  `ports` apenas para serviços públicos

---

## 15) Conclusão

Redes Docker:

- organizam comunicação
- aumentam segurança
- simplificam configuração
- são fundamentais para Compose e produção

Dominar redes é o passo final para se sentir confortável com Docker em projetos reais.

---

## 16) Próximos tópicos sugeridos

- Docker Compose avançado
- Healthchecks e dependências
- Orquestração (Kubernetes – conceitos)
- Deploy multi-container em cloud
- Observabilidade (logs, métricas)