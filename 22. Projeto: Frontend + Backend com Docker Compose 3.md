
# Projeto: Frontend + Backend com Docker Compose (Parte 3 – Final)

Esta é a **parte final** do projeto **Frontend + Backend com Docker Compose**.  
Aqui vamos fechar o ciclo e chegar em um **setup full stack próximo de produção**, mantendo tudo **didático e organizado**.

Nesta etapa vamos:
- adicionar **banco de dados**
- usar **variáveis de ambiente corretamente**
- separar **dev e prod**
- adicionar **healthchecks**
- melhorar **logs**
- consolidar a arquitetura final

---

## 1) Visão geral da arquitetura final

Arquitetura completa do projeto:

```

Navegador
│
▼
Frontend (Nginx)
│
▼
Backend (Gunicorn + Flask)
│
▼
PostgreSQL

```

Regras importantes:
- frontend **não acessa banco**
- banco **não é exposto**
- comunicação via **rede Docker**
- configuração via **variáveis de ambiente**

---

## 2) Estrutura final do projeto

```

frontend-backend-compose/
├── backend/
│   ├── app.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── index.html
│   ├── nginx.conf
│   └── Dockerfile
├── docker-compose.yml
├── docker-compose.dev.yml
├── docker-compose.prod.yml
├── .env.dev
├── .env.prod
├── .dockerignore
└── README.md

````

---

## 3) Backend final (Flask + Gunicorn + DB)

### `backend/app.py`

```python
import os
import psycopg2
from flask import Flask, jsonify

app = Flask(__name__)

DATABASE_URL = os.getenv("DATABASE_URL")

@app.get("/api/hello")
def hello():
    return jsonify(message="Projeto full stack com Docker Compose")

@app.get("/health")
def health():
    return jsonify(status="ok")

@app.get("/db-check")
def db_check():
    conn = psycopg2.connect(DATABASE_URL)
    cur = conn.cursor()
    cur.execute("SELECT 1;")
    cur.close()
    conn.close()
    return jsonify(database="connected")
````

---

### `backend/requirements.txt`

```txt
flask==3.0.0
gunicorn==21.2.0
psycopg2-binary==2.9.9
```

---

### `backend/Dockerfile`

```dockerfile
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 8000

CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

---

## 4) Frontend final (Nginx configurável)

### `frontend/index.html`

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Projeto Full Stack</title>
</head>
<body>
  <h1>Frontend + Backend + DB</h1>
  <button onclick="callApi()">Chamar API</button>
  <button onclick="checkDb()">Checar Banco</button>
  <p id="result"></p>

  <script>
    const API_URL = "__API_URL__";

    function callApi() {
      fetch(`${API_URL}/api/hello`)
        .then(res => res.json())
        .then(data => result.innerText = data.message);
    }

    function checkDb() {
      fetch(`${API_URL}/db-check`)
        .then(res => res.json())
        .then(data => result.innerText = data.database);
    }
  </script>
</body>
</html>
```

---

### `frontend/nginx.conf`

```nginx
server {
    listen 80;

    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}
```

---

### `frontend/Dockerfile`

```dockerfile
FROM nginx:alpine

ARG API_URL
ENV API_URL=${API_URL}

COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/index.html

RUN sed -i "s|__API_URL__|${API_URL}|g" /usr/share/nginx/html/index.html
```

---

## 5) Variáveis de ambiente

### `.env.dev`

```env
API_URL=http://backend:8000
DATABASE_URL=postgresql://postgres:postgres@db:5432/app
```

### `.env.prod`

```env
API_URL=http://backend:8000
DATABASE_URL=postgresql://postgres:postgres@db:5432/app
```

Diferença:

* valores reais mudariam em produção
* estrutura permanece a mesma

---

## 6) Docker Compose base

### `docker-compose.yml`

```yaml
services:
  backend:
    build: ./backend
    restart: unless-stopped
    env_file:
      - .env.dev
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 3s
      retries: 3

  frontend:
    build:
      context: ./frontend
      args:
        API_URL: ${API_URL}
    ports:
      - "8080:80"
    depends_on:
      - backend

  db:
    image: postgres:16
    restart: unless-stopped
    environment:
      POSTGRES_DB: app
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - pgdata:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5

volumes:
  pgdata:
```

---

## 7) Overrides por ambiente

### Desenvolvimento (`docker-compose.dev.yml`)

```yaml
services:
  backend:
    env_file:
      - .env.dev
```

### Produção (`docker-compose.prod.yml`)

```yaml
services:
  backend:
    env_file:
      - .env.prod
```

---

## 8) Subindo o projeto

### Desenvolvimento

```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml up --build
```

### Produção

```bash
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

---

## 9) Testes finais

* Frontend:

  ```
  http://localhost:8080
  ```

* API:

  ```
  /api/hello
  /health
  /db-check
  ```

Resultados esperados:

* frontend chama backend
* backend responde corretamente
* banco conectado
* containers `healthy`

---

## 10) Logs e monitoramento

```bash
docker compose logs -f backend
docker compose logs -f db
```

Todos os logs:

* vão para stdout
* são capturados pelo Docker
* prontos para observabilidade

---

## 11) O que você aprendeu no projeto completo

* Docker Compose multi-serviço
* Frontend desacoplado do backend
* Backend Python em produção
* Banco isolado e persistente
* Variáveis de ambiente por ambiente
* Healthchecks e restart
* Arquitetura full stack real

Este projeto **representa um padrão de mercado**.

---

## 12) Checklist final

* [ ] Frontend não acessa banco
* [ ] Backend usa Gunicorn
* [ ] Banco com volume
* [ ] Variáveis via `.env`
* [ ] Healthchecks ativos
* [ ] Restart configurado
* [ ] Dev e prod separados

---

## 13) Conclusão

Você saiu de:

* containers isolados

Para:

* **uma aplicação full stack completa**
* organizada
* previsível
* pronta para deploy

Se você entende este projeto, você entende **Docker Compose na prática**.

---

## 14) Próximos passos possíveis

* Nginx como gateway único
* React no frontend
* Autenticação (JWT)
* CI/CD com Docker
* Deploy em cloud
* Migração para Kubernetes


