
# Projeto: Frontend + Backend com Docker Compose (Parte 2)

Nesta **Parte 2**, vamos evoluir o projeto da Parte 1 para algo **mais próximo do mundo real**, mantendo a simplicidade.

Agora vamos:
- melhorar a comunicação frontend ↔ backend
- usar **variáveis de ambiente**
- rodar o backend com **Gunicorn**
- usar **rede interna do Docker** corretamente
- preparar o projeto para múltiplos ambientes (dev/prod)

Ainda **sem banco de dados**, para manter o foco na arquitetura full stack.

---

## 1) O que muda da Parte 1 para a Parte 2

Na Parte 1:
- frontend chamava o backend via `localhost`
- backend rodava com `flask run`
- configuração estava hardcoded

Na Parte 2:
- frontend usa **URL configurável**
- backend roda com **Gunicorn**
- comunicação respeita o modelo Docker
- configuração via `.env`

---

## 2) Arquitetura atualizada

```

Navegador
│
▼
Frontend (Nginx) ───▶ Backend (Gunicorn + Flask)

```

Importante:
- frontend **não conhece IP**
- backend expõe apenas o necessário
- URLs vêm de variáveis de ambiente

---

## 3) Estrutura do projeto

```

frontend-backend-compose/
├── backend/
│   ├── app.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── index.html
│   ├── nginx.conf
│   └── Dockerfile
├── docker-compose.yml
├── .env
└── .dockerignore

````

---

## 4) Backend Python (Flask + Gunicorn)

### `backend/app.py`

```python
from flask import Flask, jsonify

app = Flask(__name__)

@app.get("/api/hello")
def hello():
    return jsonify(message="Olá do backend Python (Gunicorn)")

@app.get("/health")
def health():
    return jsonify(status="ok")
````

---

### `backend/requirements.txt`

```txt
flask==3.0.0
gunicorn==21.2.0
```

---

### `backend/Dockerfile`

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY app.py .

EXPOSE 8000

CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Mudanças importantes:

* Gunicorn substitui o servidor de desenvolvimento
* porta 8000 usada como padrão de API

---

## 5) Variáveis de ambiente (.env)

Crie o arquivo `.env` na raiz:

```env
BACKEND_URL=http://backend:8000
```

Essa variável será usada pelo frontend.

---

## 6) Frontend com configuração por ambiente

Agora o frontend **não hardcodeia** o endereço do backend.

---

### `frontend/index.html`

```html
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Frontend + Backend</title>
</head>
<body>
  <h1>Frontend + Backend (Parte 2)</h1>
  <button onclick="loadMessage()">Chamar backend</button>
  <p id="result"></p>

  <script>
    const BACKEND_URL = "__BACKEND_URL__";

    function loadMessage() {
      fetch(`${BACKEND_URL}/api/hello`)
        .then(res => res.json())
        .then(data => {
          document.getElementById("result").innerText = data.message;
        })
        .catch(() => {
          document.getElementById("result").innerText = "Erro ao chamar backend";
        });
    }
  </script>
</body>
</html>
```

Note:

* usamos um placeholder `__BACKEND_URL__`
* ele será substituído no build do container

---

## 7) Nginx configurado para frontend

### `frontend/nginx.conf`

```nginx
server {
    listen 80;

    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}
```

---

### `frontend/Dockerfile`

```dockerfile
FROM nginx:alpine

ARG BACKEND_URL
ENV BACKEND_URL=${BACKEND_URL}

COPY nginx.conf /etc/nginx/conf.d/default.conf
COPY index.html /usr/share/nginx/html/index.html

RUN sed -i "s|__BACKEND_URL__|${BACKEND_URL}|g" /usr/share/nginx/html/index.html
```

O que acontece aqui:

* `ARG` recebe valor no build
* HTML é ajustado para o ambiente
* frontend fica desacoplado do backend

---

## 8) Docker Compose (docker-compose.yml)

```yaml
services:
  backend:
    build: ./backend
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      args:
        BACKEND_URL: ${BACKEND_URL}
    ports:
      - "8080:80"
    depends_on:
      - backend
```

Pontos importantes:

* frontend acessa backend via **hostname `backend`**
* nenhum IP fixo
* comunicação interna via rede Docker

---

## 9) Subindo o projeto

Na raiz do projeto:

```bash
docker compose up --build
```

---

## 10) Testando no navegador

Abra:

```
http://localhost:8080
```

Clique em **"Chamar backend"**.

Resposta esperada:

```
Olá do backend Python (Gunicorn)
```

---

## 11) O que você aprendeu nesta Parte 2

* Backend em Python rodando com Gunicorn
* Frontend configurável por ambiente
* Uso correto de rede interna do Docker
* Docker Compose como orquestrador real
* Separação clara de responsabilidades

Este já é um **padrão full stack profissional**.

---

## 12) Comparação Parte 1 vs Parte 2

| Parte 1             | Parte 2             |
| ------------------- | ------------------- |
| localhost hardcoded | URL configurável    |
| Flask dev server    | Gunicorn            |
| Comunicação simples | Comunicação correta |
| Didático            | Profissional básico |

---

## 13) Limitações (intencionais)

Ainda não temos:

* banco de dados
* autenticação
* reverse proxy completo
* CI/CD

Isso fica para a Parte 3.

---

## 14) Próxima evolução (Parte 3)

A partir daqui, podemos avançar para:

* adicionar banco de dados
* usar Nginx como reverse proxy
* frontend React
* múltiplos ambientes (dev/prod)
* healthchecks e logs completos

Se quiser, eu continuo com:

* **Projeto: Frontend + Backend com Docker Compose (Parte 3)**
* **React + Flask**
* **Nginx como gateway**
* **Arquitetura pronta para deploy**

