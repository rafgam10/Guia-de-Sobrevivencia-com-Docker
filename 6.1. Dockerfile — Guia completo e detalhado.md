
# Dockerfile — Guia completo e detalhado

Este documento é uma **anotação completa sobre Dockerfile**, pensada para estudo e consulta.  
Aqui você vai entender **o que é um Dockerfile**, **para que serve**, **como funciona cada comando**, **boas práticas**, **erros comuns** e **exemplos reais**.

---

## 1) O que é um Dockerfile

Um **Dockerfile** é um arquivo de texto que contém **instruções declarativas** para o Docker criar uma **imagem**.

Em outras palavras:
- Dockerfile → define **como a imagem será construída**
- Imagem → é o “molde”
- Container → é a imagem em execução

Fluxo mental correto:

```

Dockerfile → Image → Container

````

---

## 2) Para que serve um Dockerfile

Um Dockerfile serve para:
- padronizar ambientes
- automatizar builds
- empacotar aplicação + dependências
- tornar deploy previsível
- evitar “funciona na minha máquina”

Sem Dockerfile:
- builds manuais
- ambientes inconsistentes
- mais bugs

---

## 3) Como o Docker lê um Dockerfile

O Docker:
1. Lê o Dockerfile **de cima para baixo**
2. Executa cada instrução
3. Cria uma **camada (layer)** por instrução
4. Usa cache sempre que possível

Por isso:
- a ordem das instruções importa
- pequenas decisões impactam performance

---

## 4) Estrutura básica de um Dockerfile

Exemplo mínimo:

```dockerfile
FROM python:3.11
WORKDIR /app
COPY . .
CMD ["python", "app.py"]
````

Cada linha é uma **instrução Docker**.

---

## 5) Instruções do Dockerfile (uma por uma)

### 5.1 `FROM`

Define a **imagem base**.

```dockerfile
FROM python:3.11
```

O que faz:

- escolhe o sistema base
- traz runtime e libs iniciais

Regras:

- geralmente é a primeira instrução
- todo Dockerfile (quase sempre) precisa de `FROM`

Boas práticas:

- evite `latest`
- use versões específicas
- prefira imagens oficiais

Exemplos:

```dockerfile
FROM python:3.11-slim
FROM node:20-alpine
FROM php:8.3-apache
```

---

### 5.2 `WORKDIR`

Define o diretório de trabalho dentro do container.

```dockerfile
WORKDIR /app
```

O que faz:

- cria o diretório se não existir
- todos os comandos seguintes usam esse caminho

Evita:

```dockerfile
RUN cd /app && ...
```

Boa prática:

- sempre usar `WORKDIR`

---

### 5.3 `COPY`

Copia arquivos do host para a imagem.

```dockerfile
COPY . .
```

Formato:

```dockerfile
COPY origem destino
```

Exemplo comum:

```dockerfile
COPY requirements.txt .
COPY src/ ./src
```

Importante:

- copia apenas o que não está no `.dockerignore`
- cria uma nova camada

---

### 5.4 `ADD` (menos usado)

Semelhante ao `COPY`, mas com extras:

- extrai arquivos `.tar`
- aceita URLs

```dockerfile
ADD arquivo.tar.gz /app
```

Recomendação:

- prefira `COPY
- use `ADD` apenas se precisar dessas funcionalidades

---

### 5.5 `RUN`

Executa comandos **durante o build da imagem**.

```dockerfile
RUN pip install flask
```

O que faz:

- roda no momento do build
- cria uma nova camada
- altera a imagem final

Exemplos:

```dockerfile
RUN apt-get update && apt-get install -y curl
RUN pip install -r requirements.txt
```

Boa prática:

- agrupar comandos para reduzir camadas
- limpar caches

Exemplo:

```dockerfile
RUN apt-get update \
 && apt-get install -y curl \
 && rm -rf /var/lib/apt/lists/*
```

---

### 5.6 `CMD`

Define o **comando padrão** executado quando o container inicia.

```dockerfile
CMD ["python", "app.py"]
```

Características:

- executado no runtime
- pode ser sobrescrito no `docker run`
- apenas **um CMD ativo**

Forma recomendada (exec form):

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Evitar:

```dockerfile
CMD python app.py
```

---

### 5.7 `ENTRYPOINT`

Define o **comando principal fixo** do container.

```dockerfile
ENTRYPOINT ["python", "app.py"]
```

Diferença para `CMD`:

- `ENTRYPOINT` não é facilmente sobrescrito
- `CMD` fornece argumentos padrão

Combinação comum:

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--help"]
```

Uso típico:

- containers utilitários
- CLIs

---

### 5.8 `ENV`

Define variáveis de ambiente **dentro da imagem**.

```dockerfile
ENV PYTHONUNBUFFERED=1
```

O que faz:

- define valores padrão
- disponíveis no runtime

Importante:

- **não colocar segredos**
- pode ser sobrescrito no `docker run` ou Compose

---

### 5.9 `EXPOSE`

Documenta a porta usada pela aplicação.

```dockerfile
EXPOSE 8000
```

Importante:

- **não publica a porta**
- serve como documentação
- publicação é feita com `-p` ou `ports`

---

### 5.10 `USER`

Define o usuário que executa o processo.

```dockerfile
USER appuser
```

Por padrão:

- containers rodam como root

Boa prática:

- criar usuário não-root
- reduzir riscos de segurança

Exemplo:

```dockerfile
RUN useradd -m appuser
USER appuser
```

---

### 5.11 `VOLUME`

Define um ponto de volume.

```dockerfile
VOLUME /data
```

Uso:

- documentação
- persistência de dados

Normalmente:

- volumes são definidos no Docker Compose

---

### 5.12 `ARG`

Define variáveis **apenas no build**.

```dockerfile
ARG APP_ENV
```

Uso:

- builds condicionais
- não disponíveis no runtime

Exemplo:

```dockerfile
ARG NODE_ENV=production
```

---

### 5.13 `LABEL`

Adiciona metadados à imagem.

```dockerfile
LABEL maintainer="dev@empresa.com"
```

Útil para:

- documentação
- automação
- CI/CD

---

## 6) Camadas (layers) do Dockerfile

Cada instrução cria uma camada.

Exemplo:

```dockerfile
FROM python:3.11
COPY requirements.txt .
RUN pip install -r requirements.txt
```

Se `requirements.txt` não mudar:

- Docker reutiliza cache
- build fica mais rápido

Por isso a ordem importa.

---

## 7) `.dockerignore`

Controla o que **não deve ir para a imagem**.

Exemplo:

```txt
.git
.env
__pycache__
node_modules
```

Benefícios:

- imagens menores
- builds mais rápidos
- mais segurança

---

## 8) Exemplo completo: Dockerfile Flask (produção)

```dockerfile
FROM python:3.11-slim

WORKDIR /app

ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

RUN useradd -m appuser && chown -R appuser:appuser /app
USER appuser

EXPOSE 8000

CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Boas práticas aplicadas:

- imagem slim
- cache eficiente
- usuário não-root
- Gunicorn
- exec form no CMD

---

## 9) Erros comuns com Dockerfile

- confundir `RUN` com `CMD`
- copiar tudo antes de instalar dependências
- usar `latest`
- não usar `.dockerignore`
- rodar como root sem necessidade
- colocar segredos no Dockerfile

---

## 10) Checklist rápido

-  `FROM` com versão específica
-  `WORKDIR` definido
-  dependências copiadas antes do código
-  `RUN` limpo e otimizado
-  `CMD` em exec form
-  `.dockerignore` presente
-  usuário não-root (quando possível)

---

## 11) Conclusão

Dockerfile é:

- a base de qualquer projeto com Docker
- responsável por build, performance e segurança
- simples na sintaxe, mas poderoso no impacto

Dominar Dockerfile significa:

- entender Docker de verdade
- escrever imagens profissionais
- reduzir bugs e custos

---

## 12) Próximos tópicos recomendados

- Docker Compose avançado
- Multi-stage build
- Dockerfile para produção vs desenvolvimento
- Segurança em containers
- CI/CD com Docker
