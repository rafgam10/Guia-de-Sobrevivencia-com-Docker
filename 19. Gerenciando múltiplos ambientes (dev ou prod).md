
# Gerenciando múltiplos ambientes (dev / prod) com Docker Compose

Gerenciar **ambientes diferentes** (desenvolvimento e produção) é essencial em projetos reais.  
Com Docker Compose, isso pode ser feito de forma **limpa, previsível e versionável**.

Este guia mostra **padrões práticos**, do mais simples ao mais profissional.

---

## 1) O problema dos ambientes

Sem separação clara entre ambientes, surgem problemas como:
- código de debug em produção
- volumes de desenvolvimento em produção
- configurações inseguras
- dificuldade para testar antes do deploy

Ambientes comuns:
- `dev` (desenvolvimento)
- `prod` (produção)
- às vezes `staging`

---

## 2) Princípios fundamentais

Independente da abordagem:
- a **imagem deve ser a mesma** (ou muito próxima)
- o que muda é a **configuração**
- configuração vem de **variáveis de ambiente**
- arquivos de ambiente não devem ser commitados

---

## 3) Abordagem 1 — Arquivos `.env` separados (mais simples)

### Estrutura
```

project/  
├── docker-compose.yml  
├── .env.dev  
├── .env.prod

````

### `docker-compose.yml`
```yaml
services:
  api:
    image: minha-api
    env_file:
      - .env
````

### Rodando em dev

```bash
cp .env.dev .env
docker compose up
```

### Rodando em prod

```bash
cp .env.prod .env
docker compose up -d
```

Prós:

- simples
- fácil de entender

Contras:

- risco de subir o `.env` errado
- não escala bem para times grandes

---

## 4) Abordagem 2 — Override de arquivos (padrão oficial)

Essa é a **forma recomendada** pelo Docker Compose.

### Estrutura

```
project/
├── docker-compose.yml
├── docker-compose.dev.yml
└── docker-compose.prod.yml
```

---

### Arquivo base (comum aos ambientes)

#### `docker-compose.yml`

```yaml
services:
  api:
    image: minha-api
    restart: unless-stopped
```

---

### Configuração de desenvolvimento

#### `docker-compose.dev.yml`

```yaml
services:
  api:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - .:/app
    env_file:
      - .env.dev
```

---

### Configuração de produção

#### `docker-compose.prod.yml`

```yaml
services:
  api:
    image: minhaorg/minha-api:1.0.0
    ports:
      - "8000:8000"
    env_file:
      - .env.prod
```

---

### Rodando cada ambiente

Dev:

```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml up
```

Prod:

```bash
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

Vantagens:

- separação clara
- menos risco
- padrão de mercado

---

## 5) Abordagem 3 — Profiles (Compose moderno)

Profiles permitem ativar serviços ou configs por ambiente.

### Exemplo

```yaml
services:
  api:
    image: minha-api
    profiles:
      - dev
```

Rodando:

```bash
docker compose --profile dev up
```

Uso comum:

- serviços auxiliares
- ferramentas de debug
- mocks

Não substitui completamente override de arquivos.

---

## 6) Diferenças típicas entre dev e prod

### Desenvolvimento

- bind mount de código
- reload automático
- logs verbosos
- portas expostas
- ferramentas de debug

### Produção

- imagem pré-buildada
- Gunicorn / servidor real
- volumes apenas para dados
- logs controlados
- mínimo de exposição

---

## 7) Exemplo completo (Flask)

### Base

```yaml
services:
  api:
    restart: unless-stopped
```

---

### Dev

```yaml
services:
  api:
    build: .
    volumes:
      - .:/app
    env_file:
      - .env.dev
```

---

### Prod

```yaml
services:
  api:
    image: minhaorg/flask-api:1.0.0
    env_file:
      - .env.prod
```

A aplicação é a mesma; só muda o ambiente.

---

## 8) Variáveis por ambiente

### `.env.dev`

```env
DEBUG=true
LOG_LEVEL=debug
```

### `.env.prod`

```env
DEBUG=false
LOG_LEVEL=info
```

No código:

```python
DEBUG = os.getenv("DEBUG") == "true"
```

---

## 9) Boas práticas de segurança

- nunca commitar `.env.prod`
- usar `.env.example`
- separar segredos por ambiente
- usar secrets manager em produção
- revisar configs antes do deploy

---

## 10) Erros comuns

- usar bind mount em produção
- usar imagem `latest` em produção
- misturar configs dev/prod
- depender de `.env` manual
- mudar código entre ambientes

---

## 11) Checklist rápido

-  Base comum versionada
-  Overrides por ambiente
-  `.env` separados
-  Imagem única ou controlada
-  Sem bind mount em produção
-  Variáveis bem documentadas

---

## 12) Conclusão

Gerenciar múltiplos ambientes corretamente:

- evita erros graves
- facilita deploy
- melhora colaboração
- aproxima o projeto de padrões profissionais

Docker Compose oferece ferramentas suficientes para isso quando usado com disciplina.

---

## 13) Próximos tópicos sugeridos

- CI/CD por ambiente
- Versionamento de imagens
- Secrets por ambiente
- Logs e monitoramento
- Migração para Kubernetes

