
# Entrypoint e CMD no Docker (guia completo e prático)

Este material explica **ENTRYPOINT e CMD** de forma **completa**, **didática** e **próxima da prática real**, porque esse é um dos tópicos que mais geram confusão em Docker.

Aqui você vai entender:
- o que é ENTRYPOINT
- o que é CMD
- como eles funcionam juntos
- quando usar cada um
- erros comuns
- padrões de produção

---

## 1) O problema clássico

Muita gente:
- usa `CMD` sem entender
- mistura `ENTRYPOINT` e `CMD`
- quebra override de comandos
- cria containers difíceis de reutilizar

Resultado:
- containers rígidos
- comportamento inesperado
- dificuldade em debug

---

## 2) Conceito fundamental

Dockerfile define **como o container inicia**.

Duas instruções controlam isso:
- `ENTRYPOINT`
- `CMD`

Elas definem:
> **qual comando será executado quando o container iniciar**

---

## 3) O que é CMD

`CMD` define o **comando padrão** do container.

Exemplo:
```dockerfile
CMD ["python", "app.py"]
````

Características:

* executado quando o container inicia
* pode ser sobrescrito no `docker run`
* só pode haver **um CMD ativo**

Exemplo de override:

```bash
docker run minha-imagem echo "Olá"
```

Nesse caso:

* `CMD` é ignorado
* o comando passado no `docker run` é usado

---

## 4) Formatos de CMD

### 4.1 Exec form (recomendado)

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Vantagens:

* sem shell intermediário
* sinais (SIGTERM) funcionam corretamente
* melhor para produção

---

### 4.2 Shell form (evitar)

```dockerfile
CMD gunicorn -b 0.0.0.0:8000 app:app
```

Problemas:

* roda dentro de `/bin/sh`
* sinais não chegam corretamente
* dificulta shutdown gracioso

---

## 5) O que é ENTRYPOINT

`ENTRYPOINT` define o **comando principal fixo** do container.

Exemplo:

```dockerfile
ENTRYPOINT ["python", "app.py"]
```

Características:

* sempre executado
* não é facilmente sobrescrito
* o container se comporta como um executável

Uso típico:

* CLIs
* ferramentas utilitárias
* containers com propósito único

---

## 6) Formatos de ENTRYPOINT

### 6.1 Exec form (recomendado)

```dockerfile
ENTRYPOINT ["python", "app.py"]
```

---

### 6.2 Shell form (evitar)

```dockerfile
ENTRYPOINT python app.py
```

Mesmo problema do CMD em shell form.

---

## 7) ENTRYPOINT vs CMD (diferença essencial)

| Conceito       | ENTRYPOINT   | CMD               |
| -------------- | ------------ | ----------------- |
| Função         | Comando fixo | Argumentos padrão |
| Override fácil | Não          | Sim               |
| Uso comum      | Executável   | Configuração      |
| Obrigatório    | Não          | Não               |

---

## 8) Usando ENTRYPOINT e CMD juntos (padrão correto)

Esse é o uso **mais poderoso e correto**.

### Exemplo clássico

```dockerfile
ENTRYPOINT ["python", "app.py"]
CMD ["--help"]
```

Comportamento:

```bash
docker run minha-imagem
# executa: python app.py --help

docker run minha-imagem --version
# executa: python app.py --version
```

Ou seja:

* ENTRYPOINT = comando fixo
* CMD = argumentos padrão

---

## 9) Exemplo prático: Flask (modo simples)

### Dockerfile

```dockerfile
CMD ["python", "app.py"]
```

Override:

```bash
docker run minha-api python app.py --debug
```

Simples e flexível.

---

## 10) Exemplo prático: Gunicorn (produção)

### Dockerfile recomendado

```dockerfile
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Por que não ENTRYPOINT?

* permite override fácil
* facilita debug
* mais flexível em Compose e CI/CD

---

## 11) Exemplo prático: CLI container

### Dockerfile

```dockerfile
ENTRYPOINT ["aws"]
CMD ["--help"]
```

Uso:

```bash
docker run aws-cli s3 ls
```

Aqui:

* ENTRYPOINT é obrigatório
* CMD fornece default

---

## 12) Override de ENTRYPOINT

É possível, mas raramente desejado.

```bash
docker run --entrypoint bash minha-imagem
```

Uso comum:

* debug
* investigação

---

## 13) Entrypoint script (caso avançado)

Muito comum em produção.

### `entrypoint.sh`

```bash
#!/bin/sh
set -e

echo "Aplicando migrations..."
python manage.py migrate

exec "$@"
```

### Dockerfile

```dockerfile
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

ENTRYPOINT ["/entrypoint.sh"]
CMD ["gunicorn", "-b", "0.0.0.0:8000", "app:app"]
```

Padrão:

* ENTRYPOINT prepara o ambiente
* CMD executa a aplicação

---

## 14) Por que `exec "$@"` é essencial

Sem isso:

* sinais não chegam ao processo real
* shutdown gracioso não funciona

Sempre usar:

```bash
exec "$@"
```

---

## 15) Erros comuns

* confundir CMD com ENTRYPOINT
* usar shell form
* não usar `exec "$@"` em scripts
* esconder bugs com scripts longos
* rodar múltiplos processos no mesmo container

---

## 16) Boas práticas resumidas

* use **exec form**
* use **CMD** para aplicações web
* use **ENTRYPOINT** para CLIs
* combine ENTRYPOINT + CMD quando fizer sentido
* evite shell form
* mantenha containers simples

---

## 17) Checklist rápido

* [ ] CMD em exec form
* [ ] ENTRYPOINT apenas quando necessário
* [ ] Override funciona corretamente
* [ ] Shutdown gracioso funciona
* [ ] Container executa um único processo

---

## 18) Conclusão

ENTRYPOINT e CMD:

* controlam como o container inicia
* são fundamentais para produção
* mal usados causam bugs difíceis
* bem usados tornam containers flexíveis e confiáveis

Entender esse tema é **obrigatório** para dominar Docker.

---

## 19) Próximos tópicos sugeridos

* Entrypoint com migrations
* Signal handling em containers
* Healthchecks avançados
* Containers como CLIs
* Debug de containers em produção

